using System.Collections.Generic;
using System.Numerics;
using Microsoft.Boogie;
using System.IO;
using System.Text;
using System.Linq;
using Microsoft.Dafny;
using System.CommandLine;
using static Microsoft.Dafny.ParseErrors;


/* This file (Parser.cs) is generated from Dafny.atg by the Coco/R
 * parser generator. Do not edit this file directly. Instead, make
 * changes to Dafny.atg and then rebuild using the Makefile found
 * in the same directory as Dafny.atg.
 */

using System;
using System.Diagnostics.Contracts;
using System.Threading;

namespace Microsoft.Dafny {



public partial class Parser {
	public const int _EOF = 0;
	public const int _ident = 1;
	public const int _digits = 2;
	public const int _hexdigits = 3;
	public const int _decimaldigits = 4;
	public const int _arrayToken = 5;
	public const int _bvToken = 6;
	public const int _bool = 7;
	public const int _char = 8;
	public const int _int = 9;
	public const int _nat = 10;
	public const int _real = 11;
	public const int _ORDINAL = 12;
	public const int _object = 13;
	public const int _object_q = 14;
	public const int _string = 15;
	public const int _set = 16;
	public const int _iset = 17;
	public const int _multiset = 18;
	public const int _seq = 19;
	public const int _map = 20;
	public const int _imap = 21;
	public const int _charToken = 22;
	public const int _stringToken = 23;
	public const int _colon = 24;
	public const int _comma = 25;
	public const int _verticalbar = 26;
	public const int _doublecolon = 27;
	public const int _gets = 28;
	public const int _boredSmiley = 29;
	public const int _dot = 30;
	public const int _backtick = 31;
	public const int _semicolon = 32;
	public const int _darrow = 33;
	public const int _assume = 34;
	public const int _assert = 35;
	public const int _calc = 36;
	public const int _case = 37;
	public const int _then = 38;
	public const int _else = 39;
	public const int _as = 40;
	public const int _is = 41;
	public const int _by = 42;
	public const int _in = 43;
	public const int _decreases = 44;
	public const int _hole = 45;
	public const int _invariant = 46;
	public const int _function = 47;
	public const int _predicate = 48;
	public const int _least = 49;
	public const int _greatest = 50;
	public const int _opaque = 51;
	public const int _inductive = 52;
	public const int _twostate = 53;
	public const int _copredicate = 54;
	public const int _lemma = 55;
	public const int _static = 56;
	public const int _import = 57;
	public const int _export = 58;
	public const int _class = 59;
	public const int _trait = 60;
	public const int _datatype = 61;
	public const int _codatatype = 62;
	public const int _var = 63;
	public const int _const = 64;
	public const int _newtype = 65;
	public const int _type = 66;
	public const int _iterator = 67;
	public const int _method = 68;
	public const int _colemma = 69;
	public const int _constructor = 70;
	public const int _modifies = 71;
	public const int _reads = 72;
	public const int _requires = 73;
	public const int _ensures = 74;
	public const int _ghost = 75;
	public const int _provides = 76;
	public const int _reveals = 77;
	public const int _extends = 78;
	public const int _new = 79;
	public const int _nameonly = 80;
	public const int _older = 81;
	public const int _witness = 82;
	public const int _lbracecolon = 83;
	public const int _lbrace = 84;
	public const int _rbrace = 85;
	public const int _lbracket = 86;
	public const int _rbracket = 87;
	public const int _openparen = 88;
	public const int _closeparen = 89;
	public const int _openAngleBracket = 90;
	public const int _closeAngleBracket = 91;
	public const int _singleeq = 92;
	public const int _eq = 93;
	public const int _neq = 94;
	public const int _star = 95;
	public const int _at = 96;
	public const int _notIn = 97;
	public const int _ellipsis = 98;
	public const int _reveal = 99;
	public const int _expect = 100;
	public const int _sarrow = 101;
	public const int _qarrow = 102;
	public const int _larrow = 103;
	public const int _minus = 104;
	public const int maxT = 151;

  const bool _T = true;
  const bool _x = false;
  const int minErrDist = 2;

  public Scanner scanner;
  public Errors  errors;
  CancellationToken cancellationToken;

  public IToken t;    // last recognized token
  public IToken la;   // lookahead token
  int errDist = minErrDist;



  public Parser(Scanner scanner, Errors errors, CancellationToken cancellationToken) {
    this.scanner = scanner;
    this.errors = errors;
    this.cancellationToken = cancellationToken;
    this.la = scanner.FirstToken;
    this.t = scanner.FirstToken; // just to satisfy its non-null constraint
  }

  void SynErr (int n) {
    if (errDist >= minErrDist) {
      errors.SynErr(la.Uri, la.line, la.col, n);
    }
    errDist = 0;
  }
  
  public void SemErr(Enum errorId, IToken tok, string msg) {
    Contract.Requires(tok != null);
    Contract.Requires(msg != null);
    errors.SemErr(errorId, tok, msg);
  }

  void Get() {
    cancellationToken.ThrowIfCancellationRequested();
    for (; ; ) {
      var tmp = la;
      la = scanner.Scan();
      tmp.Next = la;
      la.Prev = tmp;
      t = tmp;
      if (la.kind <= maxT) { 
        ++errDist; 
        break;
      }

      la = t;
    }
  }

  void Expect (int n) {
    if (la.kind==n) {
      Get(); 
    } else { 
      SynErr(n); 
    }
  }

  bool StartOf (int s) {
    return set[s, la.kind];
  }

  void ExpectWeak (int n, int follow) {
    if (la.kind == n) Get();
    else {
      SynErr(n);
      while (!StartOf(follow)) {
        Get();
      }
    }
  }


  bool WeakSeparator(int n, int syFol, int repFol) {
    int kind = la.kind;
    if (kind == n) {Get(); return true;}
    else if (StartOf(repFol)) {return false;}
    else {
      SynErr(n);
      while (!(set[syFol, kind] || set[repFol, kind] || set[0, kind])) {
        Get();
        kind = la.kind;
      }
      return StartOf(syFol);
    }
  }


	void Dafny() {
		IToken includeStartToken;
		IToken fileStartToken = t;
		
		while (la.kind == 105) {
			Get();
			includeStartToken = t; 
			Expect(23);
			{
			Uri parsedFile = scanner.Uri;
			bool isVerbatimString;
			string includedFile = Util.RemoveParsedStringQuotes(t.val, out isVerbatimString);
			Util.ValidateEscaping(theOptions, t, includedFile, isVerbatimString, errors);
			includedFile = Util.RemoveEscaping(theOptions, includedFile, isVerbatimString);
			if (!Path.IsPathRooted(includedFile)) {
			 string basePath = parsedFile.Scheme == "stdin" ? "" : Path.GetDirectoryName(parsedFile.LocalPath);
			 includedFile = Path.Combine(basePath, includedFile);
			}
			var oneInclude = new Include(t, parsedFile, new Uri(Path.GetFullPath(includedFile)));
			oneInclude.RangeToken = new RangeToken(includeStartToken, t);
			theModule.Includes.Add(oneInclude);
			}
			
		}
		while (StartOf(1)) {
			TopDecl(theModule, /* isTopLevel */ true);
		}
		theModule.RangeToken = new RangeToken(fileStartToken.Next, t);
		
		while (!(la.kind == 0)) {SynErr(152); Get();}
		Expect(0);
	}

	void TopDecl(ModuleDefinition module, bool isTopLevel ) {
		DeclModifierData dmod = new DeclModifierData(); ModuleDecl submodule;
		DatatypeDecl/*!*/ dt; TopLevelDecl td; IteratorDecl iter;
		TraitDecl/*!*/ trait;
		
		while (StartOf(2)) {
			DeclModifier(ref dmod);
		}
		switch (la.kind) {
		case 57: case 58: case 108: {
			SubModuleDecl(dmod, module, out submodule, isTopLevel);
			var litmod = submodule as LiteralModuleDecl;
			if (litmod != null && litmod.ModuleDef.PrefixIds.Count != 0) {
			 var prefixModule = new PrefixNameModule(theOptions, litmod.ModuleDef.PrefixIds, litmod);
			 module.PrefixNamedModules.Add(prefixModule);
			} else {
			 if (submodule != null) {
			   module.SourceDecls.Add(submodule);
			 }
			}
			
			break;
		}
		case 59: {
			ClassDecl(dmod, module, out td);
			if (td != null) {
			 module.SourceDecls.Add(td);
			} 
			
			break;
		}
		case 61: case 62: {
			DatatypeDecl(dmod, module, out dt);
			if (dt != null) {
			 module.SourceDecls.Add(dt);
			} 
			
			break;
		}
		case 65: {
			NewtypeDecl(dmod, module, out td);
			if (td != null) {
			 module.SourceDecls.Add(td);
			} 
			
			break;
		}
		case 66: {
			SynonymTypeDecl(dmod, module, out td);
			if (td != null) {
			 module.SourceDecls.Add(td);
			} 
			
			break;
		}
		case 67: {
			IteratorDecl(dmod, module, out iter);
			if (iter != null) {
			 module.SourceDecls.Add(iter);
			} 
			
			break;
		}
		case 60: {
			TraitDecl(dmod, module, out trait);
			if (trait != null) {
			 module.SourceDecls.Add(trait);
			} 
			
			break;
		}
		case 47: case 48: case 49: case 50: case 52: case 53: case 54: case 55: case 63: case 64: case 68: case 69: case 70: {
			ClassMemberDecl(dmod, module.DefaultClass.Members, false, true);
			module.DefaultClass.SetMembersBeforeResolution(); 
			break;
		}
		default: SynErr(153); break;
		}
	}

	void DeclModifier(ref DeclModifierData dmod) {
		if (la.kind == 106) {
			Get();
			dmod.IsAbstract = true;  CheckAndSetToken(ref dmod.AbstractToken); CheckAndSetTokenOnce(ref dmod.FirstToken); 
		} else if (la.kind == 107) {
			Get();
			dmod.IsReplaceable = true;  CheckAndSetToken(ref dmod.ReplaceableToken); CheckAndSetTokenOnce(ref dmod.FirstToken); 
		} else if (la.kind == 75) {
			Get();
			dmod.IsGhost = true;  CheckAndSetToken(ref dmod.GhostToken); CheckAndSetTokenOnce(ref dmod.FirstToken); 
		} else if (la.kind == 56) {
			Get();
			dmod.IsStatic = true; CheckAndSetToken(ref dmod.StaticToken); CheckAndSetTokenOnce(ref dmod.FirstToken); 
		} else if (la.kind == 51) {
			Get();
			dmod.IsOpaque = true; CheckAndSetToken(ref dmod.OpaqueToken); CheckAndSetTokenOnce(ref dmod.FirstToken); 
		} else SynErr(154);
	}

	void SubModuleDecl(DeclModifierData dmod, ModuleDefinition parent, out ModuleDecl submodule, bool isTopLevel) {
		submodule = null; 
		if (la.kind == 108) {
			ModuleDefinition(dmod, parent, out submodule);
		} else if (la.kind == 57) {
			ModuleImport(parent, out submodule);
		} else if (la.kind == 58) {
			ModuleExport(parent, out submodule);
			if (isTopLevel) SemErr(ErrorId.p_superfluous_export, submodule.RangeToken,
			  "There is no point to an export declaration at the top level");
			
		} else SynErr(155);
	}

	void ClassDecl(DeclModifierData dmodClass, ModuleDefinition/*!*/ module, out TopLevelDecl/*!*/ c) {
		Contract.Requires(module != null);
		Contract.Ensures(Contract.ValueAtReturn(out c) != null);
		Name/*!*/ name;
		IToken tokenWithTrailingDocString = Token.NoToken;
		List<Type> parentTraits = new List<Type>();
		Attributes attrs = null;
		bool isRefining = false;
		List<TypeParameter> typeArgs = new List<TypeParameter>();
		List<MemberDecl> members = new List<MemberDecl>();
		IToken bodyStart;
		CheckDeclModifiers(ref dmodClass, "class", AllowedDeclModifiers.None);
		DeclModifierData dmod;
		
		while (!(la.kind == 0 || la.kind == 59)) {SynErr(156); Get();}
		Expect(59);
		CheckAndSetTokenOnce(ref dmodClass.FirstToken); 
		while (la.kind == 83) {
			Attribute(ref attrs);
		}
		ClassName(out name);
		tokenWithTrailingDocString = t; 
		if (la.kind == 90) {
			GenericParameters(typeArgs, true);
		}
		tokenWithTrailingDocString = t; 
		if (la.kind == 78 || la.kind == 98) {
			if (la.kind == 78) {
				ExtendsClause(parentTraits, out tokenWithTrailingDocString, null);
			} else {
				Get();
				isRefining = true; tokenWithTrailingDocString = t; 
			}
		}
		while (!(la.kind == 0 || la.kind == 84)) {SynErr(157); Get();}
		Expect(84);
		bodyStart = t;  
		while (StartOf(3)) {
			dmod = new DeclModifierData(); 
			while (StartOf(2)) {
				DeclModifier(ref dmod);
			}
			ClassMemberDecl(dmod, members, true, false);
		}
		Expect(85);
		c = new ClassDecl(new RangeToken(dmodClass.FirstToken, t), name, module, typeArgs, members, attrs, isRefining, parentTraits);
		c.BodyStartTok = bodyStart;
		c.TokenWithTrailingDocString = tokenWithTrailingDocString;
		
	}

	void DatatypeDecl(DeclModifierData dmod, ModuleDefinition/*!*/ module, out DatatypeDecl/*!*/ dt) {
		Contract.Requires(module != null);
		Contract.Ensures(Contract.ValueAtReturn(out dt)!=null);
		Name/*!*/ name;
		Attributes attrs = null;
		List<TypeParameter/*!*/> typeArgs = new List<TypeParameter/*!*/>();
		List<Type> parentTraits = new List<Type>();
		List<DatatypeCtor/*!*/> ctors = new List<DatatypeCtor/*!*/>();
		IToken bodyStart = Token.NoToken;  // dummy assignment
		bool isRefining = false;
		bool co = false;
		CheckDeclModifiers(ref dmod, "datatype or codatatype", AllowedDeclModifiers.None);
		var members = new List<MemberDecl>();
		
		while (!(la.kind == 0 || la.kind == 61 || la.kind == 62)) {SynErr(158); Get();}
		if (la.kind == 61) {
			Get();
		} else if (la.kind == 62) {
			Get();
			co = true; 
		} else SynErr(159);
		CheckAndSetTokenOnce(ref dmod.FirstToken); 
		while (la.kind == 83) {
			Attribute(ref attrs);
		}
		DatatypeName(out name);
		if (la.kind == 90) {
			GenericParameters(typeArgs, true);
		}
		if (la.kind == 78) {
			ExtendsClause(parentTraits, out _, co ? "codatatype" : "datatype");
		}
		if (la.kind == 92) {
			Get();
			bodyStart = t; 
			if (la.kind == 98) {
				Get();
				SemErr(ErrorId.p_bad_datatype_refinement, t, // Help users adjust to the new syntax
				$"in refining a datatype, the '...' replaces the '=' token and everything up to a left brace starting the declaration of the body; only members of the body may be changed in a datatype refinement"); 
			}
			if (la.kind == 26) {
				Get();
			}
			DatatypeMemberDecl(ctors);
			while (la.kind == 26) {
				Get();
				DatatypeMemberDecl(ctors);
			}
		} else if (la.kind == 98) {
			Get();
			isRefining = true; bodyStart = t; 
		} else SynErr(160);
		if (la.kind == 84) {
			TypeMembers(module, members);
		}
		if (co) {
		 dt = new CoDatatypeDecl(new RangeToken(dmod.FirstToken, t), name, module, typeArgs, ctors, parentTraits, members, attrs, isRefining);
		} else {
		 dt = new IndDatatypeDecl(new RangeToken(dmod.FirstToken, t), name, module, typeArgs, ctors, parentTraits, members, attrs, isRefining);
		}
		dt.BodyStartTok = bodyStart;
		dt.TokenWithTrailingDocString = bodyStart;
		
	}

	void NewtypeDecl(DeclModifierData dmod, ModuleDefinition module, out TopLevelDecl td) {
		Name name;
		IToken bvId;
		Attributes attrs = null;
		td = null;
		Type baseType = null;
		Expression constraint;
		Expression witness = null;
		CheckDeclModifiers(ref dmod, "newtype", AllowedDeclModifiers.None);
		List<Type> parentTraits = new List<Type>();
		var members = new List<MemberDecl>();
		
		Expect(65);
		CheckAndSetTokenOnce(ref dmod.FirstToken); 
		while (la.kind == 83) {
			Attribute(ref attrs);
		}
		NewtypeName(out name);
		if (la.kind == 78) {
			ExtendsClause(parentTraits, out _, "newtype");
		}
		if (la.kind == 92) {
			Get();
			if (la.kind == 98) {
				Get();
				SemErr(ErrorId.p_misplaced_ellipsis_in_newtype, t, // Help users adjust to the new syntax
				$"in refining a newtype, the '...' replaces the '=' token and everything up to the left brace starting the declaration of the newtype body (if any); a newtype refinement may not change the base type of the newtype"); 
			}
			if (IsIdentColonOrBar()) {
				LocalVarName(out bvId);
				if (la.kind == 24) {
					Get();
					Type(out baseType);
				}
				if (baseType == null) { baseType = new InferredTypeProxy(); } 
				Expect(26);
				Expression(out constraint, false, true);
				var witnessKind = SubsetTypeDecl.WKind.CompiledZero; 
				if (IsWitness()) {
					if (la.kind == 75) {
						Get();
						Expect(82);
						witnessKind = SubsetTypeDecl.WKind.Ghost; 
						Expression(out witness, false, true);
					} else if (la.kind == 82) {
						Get();
						if (la.kind == 95) {
							Get();
							witnessKind = SubsetTypeDecl.WKind.OptOut; 
						} else if (StartOf(4)) {
							Expression(out witness, false, true);
							witnessKind = SubsetTypeDecl.WKind.Compiled; 
						} else SynErr(161);
					} else SynErr(162);
				}
				if (la.kind == 84) {
					TypeMembers(module, members);
				}
				td = new NewtypeDecl(new RangeToken(dmod.FirstToken, t), name, module, 
				 new BoundVar(bvId, bvId.val, baseType){ 
				    IsTypeExplicit = true 
				 }, 
				 constraint, witnessKind, witness, parentTraits, members, attrs, isRefining: false);
				
			} else if (StartOf(5)) {
				Type(out baseType);
				if (la.kind == 84) {
					TypeMembers(module, members);
				}
				td = new NewtypeDecl(new RangeToken(dmod.FirstToken, t), name, module, baseType, parentTraits, members, attrs, isRefining: false); 
			} else SynErr(163);
		} else if (la.kind == 98) {
			Get();
			if (la.kind == 84) {
				TypeMembers(module, members);
			}
			baseType = null; // Base type is not known yet
			td = new NewtypeDecl(new RangeToken(dmod.FirstToken, t), name, module, baseType, parentTraits, members, attrs, isRefining: true);
			
		} else SynErr(164);
		if (td != null) {
		 td.TokenWithTrailingDocString = t; 
		}   
	}

	void SynonymTypeDecl(DeclModifierData dmod, ModuleDefinition module, out TopLevelDecl td) {
		IToken bvId;
		Attributes attrs = null;
		var characteristics = new TypeParameter.TypeParameterCharacteristics(false);
		var typeArgs = new List<TypeParameter>();
		td = null;
		Type ty = null;
		Expression constraint;
		Expression witness = null;
		var kind = "abstract type";
		List<Type> parentTraits = new List<Type>();
		var members = new List<MemberDecl>();
		var isRefining = false;
		
		Expect(66);
		CheckAndSetTokenOnce(ref dmod.FirstToken); 
		while (la.kind == 83) {
			Attribute(ref attrs);
		}
		SynonymTypeName(out var name);
		while (la.kind == 88) {
			TypeParameterCharacteristics(ref characteristics);
		}
		if (la.kind == 90) {
			GenericParameters(typeArgs, true);
		}
		if (StartOf(6)) {
			if (la.kind == 92) {
				Get();
				if (IsIdentColonOrBar()) {
					LocalVarName(out bvId);
					if (la.kind == 24) {
						Get();
						Type(out ty);
					}
					if (ty == null) { ty = new InferredTypeProxy(); } 
					Expect(26);
					Expression(out constraint, false, true);
					var witnessKind = SubsetTypeDecl.WKind.CompiledZero; 
					if (IsWitness()) {
						if (la.kind == 75) {
							Get();
							Expect(82);
							witnessKind = SubsetTypeDecl.WKind.Ghost; 
							Expression(out witness, false, true);
						} else if (la.kind == 82) {
							Get();
							if (la.kind == 95) {
								Get();
								witnessKind = SubsetTypeDecl.WKind.OptOut; 
							} else if (StartOf(4)) {
								Expression(out witness, false, true);
								witnessKind = SubsetTypeDecl.WKind.Compiled; 
							} else SynErr(165);
						} else SynErr(166);
					}
					td = new SubsetTypeDecl(new RangeToken(dmod.FirstToken, t), name, characteristics, typeArgs, module, 
					  new BoundVar(bvId, bvId.val, ty){ IsTypeExplicit = !(ty is InferredTypeProxy) }, constraint, witnessKind, witness, attrs);
					kind = "subset type";
					
				} else if (StartOf(5)) {
					Type(out ty);
					td = new TypeSynonymDecl(new RangeToken(dmod.FirstToken, t), name, characteristics, typeArgs, module, ty, attrs);
					kind = "type synonym";
					
				} else SynErr(167);
			} else if (la.kind == 98) {
				Get();
				isRefining = true; 
				if (la.kind == 84) {
					TypeMembers(module, members);
				}
			} else if (la.kind == 78) {
				ExtendsClause(parentTraits, out _, "abstract type");
				if (la.kind == 84) {
					TypeMembers(module, members);
				}
			} else {
				TypeMembers(module, members);
			}
		}
		if (td == null) {
		 if (module is DefaultModuleDefinition or FileModuleDefinition) {
		   // abstract type declarations at the very outermost program scope get an automatic (!new)
		   characteristics.ContainsNoReferenceTypes = true;
		 }
		 td = new AbstractTypeDecl(new RangeToken(dmod.FirstToken, t), name, module, characteristics, typeArgs, parentTraits, members, attrs, isRefining);
		}
		td.TokenWithTrailingDocString = t;
		
		CheckDeclModifiers(ref dmod, kind, AllowedDeclModifiers.None); 
	}

	void IteratorDecl(DeclModifierData dmod, ModuleDefinition module, out IteratorDecl/*!*/ iter) {
		Contract.Ensures(Contract.ValueAtReturn(out iter) != null);
		Attributes attrs = null;
		List<TypeParameter/*!*/>/*!*/ typeArgs = new List<TypeParameter/*!*/>();
		List<Formal/*!*/> ins = new List<Formal/*!*/>();
		List<Formal/*!*/> outs = new List<Formal/*!*/>();
		List<FrameExpression/*!*/> reads = new List<FrameExpression/*!*/>();
		List<FrameExpression/*!*/> mod = new List<FrameExpression/*!*/>();
		List<Expression/*!*/> decreases = new List<Expression>();
		List<AttributedExpression/*!*/> req = new List<AttributedExpression/*!*/>();
		List<AttributedExpression/*!*/> ens = new List<AttributedExpression/*!*/>();
		List<AttributedExpression/*!*/> yieldReq = new List<AttributedExpression/*!*/>();
		List<AttributedExpression/*!*/> yieldEns = new List<AttributedExpression/*!*/>();
		List<Expression/*!*/> dec = new List<Expression/*!*/>();
		Attributes readsAttrs = null;
		Attributes modAttrs = null;
		Attributes decrAttrs = null;
		BlockStmt body = null;
		IToken signatureEllipsis = null;
		IToken bodyStart = Token.NoToken;
		IToken bodyEnd = Token.NoToken;
		CheckDeclModifiers(ref dmod, "iterator", AllowedDeclModifiers.None);
		
		while (!(la.kind == 0 || la.kind == 67)) {SynErr(168); Get();}
		Expect(67);
		CheckAndSetTokenOnce(ref dmod.FirstToken); 
		while (la.kind == 83) {
			Attribute(ref attrs);
		}
		IteratorName(out var name);
		if (la.kind == 88 || la.kind == 90) {
			if (la.kind == 90) {
				GenericParameters(typeArgs, true);
			}
			Formals(true, true, false, false, ins);
			if (la.kind == 112 || la.kind == 113) {
				if (la.kind == 112) {
					Get();
				} else {
					Get();
					SemErr(ErrorId.p_should_be_yields_instead_of_returns, t, "iterators don't have a 'returns' clause; did you mean 'yields'?"); 
				}
				Formals(false, true, false, false, outs);
			}
		} else if (la.kind == 98) {
			Get();
			signatureEllipsis = t; 
		} else SynErr(169);
		IteratorSpec(reads, mod, decreases, req, ens, yieldReq, yieldEns, ref readsAttrs, ref modAttrs, ref decrAttrs);
		if (la.kind == 84) {
			BlockStmt(out body, out bodyStart, out bodyEnd);
		}
		iter = new IteratorDecl(new RangeToken(dmod.FirstToken, t), name, module, typeArgs, ins, outs,
		                       new Specification<FrameExpression>(reads, readsAttrs),
		                       new Specification<FrameExpression>(mod, modAttrs),
		                       new Specification<Expression>(decreases, decrAttrs),
		                       req, ens, yieldReq, yieldEns,
		                       body, attrs, signatureEllipsis);
		iter.BodyStartTok = bodyStart;
		
	}

	void TraitDecl(DeclModifierData dmodIn, ModuleDefinition/*!*/ module, out TraitDecl/*!*/ trait) {
		Contract.Requires(module != null);
		Contract.Ensures(Contract.ValueAtReturn(out trait) != null);
		CheckDeclModifiers(ref dmodIn, "trait", AllowedDeclModifiers.None);
		IToken/*!*/ tokenWithTrailingDocString;
		List<Type> parentTraits = new List<Type>();
		Attributes attrs = null;
		bool isRefining = false;
		List<TypeParameter/*!*/> typeArgs = new List<TypeParameter/*!*/>(); //traits should not support type parameters at the moment
		List<MemberDecl/*!*/> members = new List<MemberDecl/*!*/>();
		IToken bodyStart;
		DeclModifierData dmod;
		
		while (!(la.kind == 0 || la.kind == 60)) {SynErr(170); Get();}
		Expect(60);
		CheckAndSetTokenOnce(ref dmodIn.FirstToken); 
		while (la.kind == 83) {
			Attribute(ref attrs);
		}
		ClassName(out var name);
		tokenWithTrailingDocString = t; 
		if (la.kind == 90) {
			GenericParameters(typeArgs, true);
		}
		tokenWithTrailingDocString = t; 
		if (la.kind == 78 || la.kind == 98) {
			if (la.kind == 78) {
				ExtendsClause(parentTraits, out tokenWithTrailingDocString, null);
			} else {
				Get();
				isRefining = true; tokenWithTrailingDocString = t; 
			}
		}
		Expect(84);
		bodyStart = t; 
		while (StartOf(3)) {
			dmod  = new DeclModifierData(); 
			while (StartOf(2)) {
				DeclModifier(ref dmod);
			}
			ClassMemberDecl(dmod, members, true, false);
		}
		Expect(85);
		trait = new TraitDecl(new RangeToken(dmodIn.FirstToken, t), name, module, typeArgs, members, attrs, isRefining, parentTraits);
		trait.BodyStartTok = bodyStart;
		trait.TokenWithTrailingDocString = tokenWithTrailingDocString;
		
	}

	void ClassMemberDecl(DeclModifierData dmod, List<MemberDecl> mm, bool allowConstructors, bool moduleLevelDecl) {
		Contract.Requires(cce.NonNullElements(mm));
		Method/*!*/ m;
		Function/*!*/ f;
		
		if (la.kind == 63) {
			if (moduleLevelDecl) {
			 SemErr(ErrorId.p_top_level_field, la, "fields are not allowed to be declared at the module level; instead, wrap the field in a 'class' declaration");
			 dmod.IsStatic = false;
			}
			
			FieldDecl(dmod, mm);
		} else if (la.kind == 64) {
			ConstantFieldDecl(dmod, mm, moduleLevelDecl);
		} else if (IsFunctionDecl()) {
			if (moduleLevelDecl && dmod.StaticToken != null) {
			 errors.Warning(ErrorId.p_module_level_function_always_static, dmod.StaticToken, "module-level functions are always non-instance, so the 'static' keyword is not allowed here");
			 dmod.IsStatic = false;
			}
			
			FunctionDecl(dmod, out f);
			mm.Add(f); 
		} else if (StartOf(7)) {
			if (moduleLevelDecl && dmod.StaticToken != null) {
			 errors.Warning(ErrorId.p_module_level_method_always_static, dmod.StaticToken, "module-level methods are always non-instance, so the 'static' keyword is not allowed here");
			 dmod.IsStatic = false;
			}
			
			MethodDecl(dmod, allowConstructors, out m);
			mm.Add(m); 
		} else SynErr(171);
	}

	void ModuleDefinition(DeclModifierData dmod, ModuleDefinition parent, out ModuleDecl submodule) {
		Expect(108);
		CheckAndSetTokenOnce(ref dmod.FirstToken);
		Attributes attrs = null;
		IToken/*!*/ iderr;
		IToken tokenWithTrailingDocString;
		var prefixIds = new List<IToken>();
		List<Name> idRefined = null;
		ModuleDefinition module;
		ImplementationKind implementationKind = ImplementationKind.Refinement;
		submodule = null; // appease compiler
		var dafnyOptionsBackup = theOptions;
		CheckDeclModifiers(ref dmod, "module", AllowedDeclModifiers.Abstract | AllowedDeclModifiers.Replaceable);
		
		while (la.kind == 83) {
			Attribute(ref attrs);
		}
		ApplyOptionsFromAttributes(attrs); 
		ModuleQualifiedName(out var names);
		var name = names[^1];
		prefixIds = names.GetRange(0,names.Count-1).Select(n => n.StartToken).ToList();
		
		if (StartOf(8)) {
			if (la.kind == 109) {
				Get();
				ModuleQualifiedName(out idRefined);
				implementationKind = ImplementationKind.Refinement; 
			} else if (la.kind == 110) {
				Get();
				ModuleQualifiedName(out idRefined);
				implementationKind = ImplementationKind.Replacement; 
			} else {
				Ident(out iderr);
				SemErr(ErrorId.p_bad_module_decl, t, $"expected either a '{{' or a 'refines' keyword here, found {iderr.val}"); 
			}
		}
		module = new ModuleDefinition(RangeToken.NoToken, name, prefixIds, GetModuleKind(dmod), false,
		                                 idRefined == null ? null : new Implements(implementationKind, new ModuleQualifiedId(idRefined)), parent, attrs);
		
		while (!(la.kind == 0 || la.kind == 84)) {SynErr(172); Get();}
		tokenWithTrailingDocString = t; 
		Expect(84);
		module.BodyStartTok = t; 
		while (StartOf(1)) {
			TopDecl(module, /* isTopLevel */ false);
		}
		Expect(85);
		module.RangeToken = new RangeToken(dmod.FirstToken, t);
		module.TokenWithTrailingDocString = tokenWithTrailingDocString;
		submodule = new LiteralModuleDecl(theOptions, module, parent, Guid.NewGuid());
		submodule.RangeToken = module.RangeToken;
		theOptions = dafnyOptionsBackup;
		
	}

	void ModuleImport(ModuleDefinition parent, out ModuleDecl submodule) {
		Expect(57);
		bool opened = false;
		List<IToken> idExports = new List<IToken>();
		var startToken = t;
		submodule = null;
		
		if (la.kind == 111) {
			Get();
			opened = true; 
		}
		int lookAhead = scanner.Peek().kind; 
		if (lookAhead == _colon) {
			ModuleName(out var name);
			Expect(24);
			QualifiedModuleExport(out var namePath, out idExports);
			submodule = new AbstractModuleDecl(theOptions, new RangeToken(startToken, t), new ModuleQualifiedId(namePath),
			                                 name, parent, opened, idExports, Guid.NewGuid()); 
		} else if (lookAhead == _singleeq) {
			ModuleName(out var name);
			Expect(92);
			QualifiedModuleExport(out var namePath, out idExports);
			submodule = new AliasModuleDecl(theOptions, new RangeToken(startToken, t), new ModuleQualifiedId(namePath),
			                                 name, parent, opened, idExports, Guid.NewGuid()); 
		} else if (StartOf(9)) {
			QualifiedModuleExport(out var namePath, out idExports);
			submodule = new AliasModuleDecl(theOptions, new RangeToken(startToken, t), new ModuleQualifiedId(namePath),
			                           new Name(new RangeToken(startToken,startToken), namePath[^1].Value), parent, opened, idExports, Guid.NewGuid());
			
		} else SynErr(173);
	}

	void ModuleExport(ModuleDefinition parent, out ModuleDecl submodule) {
		Expect(58);
		IToken exportId = t;
		IToken/*!*/ id;
		List<ExportSignature> exports = new List<ExportSignature>();;
		List<IToken> extends = new List<IToken>();
		var startToken = t;
		bool provideAll = false;
		bool revealAll = false;
		bool isDefault = false;
		bool isRefining = false;
		ExportSignature exsig;
		IToken laa;
		
		if (IsIdentifier(la.kind) || la.kind==_digits) {
			ExportId(out exportId);
			if (exportId.line == la.line && (exportId.val == "least" || exportId.val == "greatest") && la.kind == _predicate)
			   errors.Warning(ErrorId.p_misplaced_least_or_greatest, exportId, 
			       $"the {exportId.val} token is the identifier for the export set, not an adjective for an extreme predicate");
			
		}
		if (la.kind == 98) {
			Get();
			isRefining = true; 
		}
		while (la.kind == 76 || la.kind == 77 || la.kind == 78) {
			if (la.kind == 76) {
				Get();
				if (StartOf(10)) {
					ExportSignature(true, out exsig);
					exports.Add(exsig); 
					scanner.ResetPeek(); laa = scanner.Peek(); 
					while (la.kind == _comma && laa.kind != _provides && laa.kind != _reveals && laa.kind != _extends ) {
						Expect(25);
						ExportSignature(true, out exsig);
						exports.Add(exsig); 
						scanner.ResetPeek(); laa = scanner.Peek(); 
					}
				} else if (la.kind == 95) {
					Get();
					provideAll = true; 
				} else SynErr(174);
			} else if (la.kind == 77) {
				Get();
				if (StartOf(10)) {
					ExportSignature(false, out exsig);
					exports.Add(exsig); 
					scanner.ResetPeek(); laa = scanner.Peek(); 
					while (la.kind == _comma && laa.kind != _provides && laa.kind != _reveals && laa.kind != _extends ) {
						Expect(25);
						ExportSignature(false, out exsig);
						exports.Add(exsig); 
						scanner.ResetPeek(); laa = scanner.Peek(); 
					}
				} else if (la.kind == 95) {
					Get();
					revealAll = true; 
				} else SynErr(175);
			} else {
				Get();
				ExportId(out id);
				extends.Add(id); 
				scanner.ResetPeek(); laa = scanner.Peek(); 
				while (la.kind == _comma && laa.kind != _provides && laa.kind != _reveals && laa.kind != _extends ) {
					Expect(25);
					ExportId(out id);
					extends.Add(id); 
					scanner.ResetPeek(); laa = scanner.Peek(); 
				}
			}
			if (la.kind == 25) {
				Get();
				SemErr(ErrorId.p_extraneous_comma_in_export, t, "no comma is allowed between provides and reveals and extends clauses in an export declaration"); 
			}
		}
		Name name;
		if (exportId.val == "export" || exportId.val == parent.Name) {
		 isDefault = true;
		 name = new Name(exportId.ToRange(), parent.Name);
		} else {
		 name = new Name(exportId);
		}
		submodule = new ModuleExportDecl(theOptions, new RangeToken(startToken, t), name, parent, exports, extends, provideAll, revealAll, isDefault, isRefining, Guid.NewGuid());
		
	}

	void Attribute(ref Attributes attrs) {
		IToken openBrace, closeBrace;
		IToken x = null;
		var args = new List<Expression>();
		
		Expect(83);
		openBrace = t; 
		ConvertKeywordTokenToIdent(); 
		AttributeName(out x);
		if (StartOf(4)) {
			Expressions(args);
		}
		Expect(85);
		closeBrace = t; 
		var rtok = new RangeToken(openBrace, t);
		if (!CheckAttribute(errors, x, rtok)) return;
		attrs = new UserSuppliedAttributes(x, openBrace, closeBrace, args, attrs);
		attrs.RangeToken = rtok;
		
	}

	void ModuleQualifiedName(out List<Name> names) {
		names = new List<Name>();
		Name name;
		
		ModuleName(out name);
		names.Add(name); 
		while (la.kind == 30) {
			Get();
			ModuleName(out name);
			names.Add(name); 
		}
	}

	void Ident(out IToken/*!*/ x) {
		Contract.Ensures(Contract.ValueAtReturn(out x) != null); 
		if (la.kind == 1) {
			Get();
		} else if (la.kind == 49) {
			Get();
			t.kind = _ident; 
		} else if (la.kind == 50) {
			Get();
			t.kind = _ident; 
		} else if (la.kind == 81) {
			Get();
			t.kind = _ident; 
		} else if (la.kind == 51) {
			Get();
			t.kind = _ident; 
			errors.Deprecated(ErrorId.p_deprecated_opaque_as_identifier, t, "opaque is deprecated as an identifier. It will soon become a reserved word. Use a different name."); 
		} else SynErr(176);
		x = t; 
	}

	void ModuleName(out Name name) {
		Name(out name);
	}

	void QualifiedModuleExport(out List<Name> namePath, out List<IToken> exports) {
		exports = new List<IToken>();
		
		ModuleQualifiedName(out namePath);
		if (la.kind == 31) {
			Get();
			ModuleExportSuffix(exports);
		}
	}

	void ExportId(out IToken id) {
		NoUSIdentOrDigits(out id);
	}

	void NoUSIdentOrDigits(out IToken id) {
		id = Token.NoToken; 
		if (StartOf(9)) {
			NoUSIdent(out id);
		} else if (la.kind == 2) {
			Get();
			id = t; 
		} else SynErr(177);
	}

	void ExportSignature(bool opaque, out ExportSignature exsig) {
		IToken prefix; IToken suffix = null; IToken startToken = null;
		
		TypeNameOrCtorSuffix(out prefix);
		startToken = t; 
		if (la.kind == 30) {
			Get();
			TypeNameOrCtorSuffix(out suffix);
		}
		if (suffix != null) {
		 exsig = new ExportSignature(prefix, prefix.val, suffix, suffix.val, opaque);
		} else {
		 exsig = new ExportSignature(prefix, prefix.val, opaque);
		}
		exsig.RangeToken = new RangeToken(startToken, t);
		
	}

	void TypeNameOrCtorSuffix(out IToken id) {
		id = Token.NoToken; 
		IdentOrDigits(out id);
	}

	void Name(out Name name) {
		NoUSIdent(out var t);
		name = new Name(t); 
	}

	void ModuleExportSuffix(List<IToken> exports) {
		IToken id; 
		if (StartOf(10)) {
			ExportId(out id);
			exports.Add(id); 
		} else if (la.kind == 84) {
			Get();
			ExportId(out id);
			exports.Add(id); 
			while (la.kind == 25) {
				Get();
				ExportId(out id);
				exports.Add(id); 
			}
			Expect(85);
		} else SynErr(178);
	}

	void ClassName(out Name name) {
		Name(out name);
	}

	void GenericParameters(List<TypeParameter/*!*/>/*!*/ typeArgs, bool allowVariance) {
		Contract.Requires(cce.NonNullElements(typeArgs));
		TypeParameter.TypeParameterCharacteristics characteristics;
		TypeParameter.TPVarianceSyntax variance = TypeParameter.TPVarianceSyntax.NonVariant_Strict;  // assignment is to please compiler
		characteristics = new TypeParameter.TypeParameterCharacteristics(false);
		
		Name name;
		
		Expect(90);
		IToken startToken = t.Next; 
		if (StartOf(11)) {
			Variance(out variance);
			if (!allowVariance) { SemErr(ErrorId.p_type_parameter_variance_forbidden, t, "type-parameter variance is not allowed to be specified in this context"); }  
			
		}
		TypeVariableName(out name);
		while (la.kind == 88) {
			TypeParameterCharacteristics(ref characteristics);
		}
		typeArgs.Add(new TypeParameter(new RangeToken(startToken, t), name, variance, characteristics)); 
		while (la.kind == 25) {
			Get();
			variance = TypeParameter.TPVarianceSyntax.NonVariant_Strict;
			characteristics = new TypeParameter.TypeParameterCharacteristics(false);
			startToken = t.Next; 
			
			if (StartOf(11)) {
				Variance(out variance);
				if (!allowVariance) { SemErr(ErrorId.p_type_parameter_variance_forbidden, t, "type-parameter variance is not allowed to be specified in this context"); } 
				
			}
			TypeVariableName(out name);
			while (la.kind == 88) {
				TypeParameterCharacteristics(ref characteristics);
			}
			typeArgs.Add(new TypeParameter(new RangeToken(startToken, t), name, variance, characteristics)); 
		}
		Expect(91);
	}

	void ExtendsClause(List<Type> parentTraits, out IToken tokenWithTrailingDocString, string requiresNonReferenceTraitsFor ) {
		Type parentTrait;
		
		Expect(78);
		if (requiresNonReferenceTraitsFor == "newtype" && theOptions.Get(CommonOptionBag.GeneralTraits) != CommonOptionBag.GeneralTraitsOptions.Full) {
		 SemErr(ErrorId.p_general_traits_beta, t,
		   $"{requiresNonReferenceTraitsFor} extending traits is a beta feature; use /generalTraits:full to engage");
		} else if (requiresNonReferenceTraitsFor != null && theOptions.Get(CommonOptionBag.GeneralTraits) == CommonOptionBag.GeneralTraitsOptions.Legacy) {
		 SemErr(ErrorId.p_general_traits_beta, t,
		   $"{requiresNonReferenceTraitsFor} extending traits is a beta feature; use /generalTraits:datatype to engage");
		}
		
		Type(out parentTrait);
		parentTraits.Add(parentTrait); tokenWithTrailingDocString = t; 
		while (la.kind == 25) {
			Get();
			Type(out parentTrait);
			parentTraits.Add(parentTrait); tokenWithTrailingDocString = t; 
		}
	}

	void Type(out Type ty) {
		Contract.Ensures(Contract.ValueAtReturn(out ty) != null); IToken/*!*/ tok; 
		TypeAndToken(out tok, out ty, false);
	}

	void FieldDecl(DeclModifierData dmod, List<MemberDecl> mm) {
		Contract.Requires(cce.NonNullElements(mm));
		Attributes attrs = null;
		Type/*!*/ ty;
		Name name;
		CheckDeclModifiers(ref dmod, "field", AllowedDeclModifiers.Ghost);
		var startToken = dmod.FirstToken;
		
		while (!(la.kind == 0 || la.kind == 63)) {SynErr(179); Get();}
		Expect(63);
		startToken = startToken ?? t; 
		while (la.kind == 83) {
			Attribute(ref attrs);
		}
		FIdentType(out name, out ty);
		var f = new Field(new RangeToken(startToken, t), name, dmod.IsGhost, ty, attrs);
		mm.Add(f); f.TokenWithTrailingDocString = t;
		
		while (la.kind == 25) {
			Get();
			startToken = t; 
			FIdentType(out name, out ty);
			f = new Field(new RangeToken(startToken, t), name, dmod.IsGhost, ty, attrs);
			mm.Add(f); f.TokenWithTrailingDocString = t;
			
		}
		OldSemi();
	}

	void ConstantFieldDecl(DeclModifierData dmod, List<MemberDecl/*!*/>/*!*/ mm, bool moduleLevelDecl) {
		Contract.Requires(cce.NonNullElements(mm));
		Attributes attrs = null;
		Type/*!*/ ty;
		Expression e = null;
		if (moduleLevelDecl && dmod.StaticToken != null) {
		 errors.Warning(ErrorId.p_module_level_const_always_static, dmod.StaticToken, "module-level const declarations are always non-instance, so the 'static' keyword is not allowed here");
		 dmod.IsStatic = false;
		}
		CheckDeclModifiers(ref dmod, "field", AllowedDeclModifiers.Ghost | AllowedDeclModifiers.Static | AllowedDeclModifiers.Opaque);
		
		while (!(la.kind == 0 || la.kind == 64)) {SynErr(180); Get();}
		Expect(64);
		CheckAndSetTokenOnce(ref dmod.FirstToken); 
		while (la.kind == 83) {
			Attribute(ref attrs);
		}
		if (!IsIdentifier(la.kind) && la.kind != _digits) {
			SemErr(ErrorId.p_const_decl_missing_identifier, la, "expected an identifier after 'const' and any attributes"); 
		} else if (StartOf(10)) {
			CIdentType(out var name, out ty);
			if (ty == null) { ty = new InferredTypeProxy(); } 
			if (la.kind == 98) {
				Get();
			}
			if (la.kind == 28 || la.kind == 92) {
				if (la.kind == 28) {
					Get();
				} else {
					Get();
					SemErr(ErrorId.p_bad_const_initialize_op, t, "a const field should be initialized using ':=', not '='"); 
				}
				Expression(out e, false, true);
			}
			if (e == null && ty is InferredTypeProxy) {
			 SemErr(ErrorId.p_const_is_missing_type_or_init, name.StartToken, "a const declaration must have a type or a RHS value");
			}
			var c = new ConstantField(new RangeToken(dmod.FirstToken, t), name, e, dmod.IsStatic, dmod.IsGhost, dmod.IsOpaque, ty, attrs);
			mm.Add(c);
			
			OldSemi();
			c.TokenWithTrailingDocString = t; 
		} else SynErr(181);
	}

	void FunctionDecl(DeclModifierData dmod, out Function/*!*/ f) {
		Contract.Ensures(Contract.ValueAtReturn(out f) != null);
		Attributes attrs = null;
		Name name = null; // To please compiler
		List<TypeParameter> typeArgs = new List<TypeParameter>();
		List<Formal> formals = new List<Formal>();
		Formal/*!*/ result = null;
		Type/*!*/ returnType = new BoolType();
		List<AttributedExpression> reqs = new List<AttributedExpression>();
		List<AttributedExpression> ens = new List<AttributedExpression>();
		List<FrameExpression> reads = new List<FrameExpression>();
		List<Expression> decreases;
		Attributes decAttrs = null;
		Attributes readsAttrs = null;
		Expression body = null;
		bool isPredicate = false; bool isLeastPredicate = false; bool isGreatestPredicate = false;
		IToken/*?*/ headToken = null; // used only for a basic "function" or "predicate"
		IToken/*?*/ functionMethodToken = null; // used only for a basic "function" or "predicate"
		IToken tokenWithTrailingDocString = Token.NoToken;
		IToken bodyStart = Token.NoToken;
		IToken bodyEnd = Token.NoToken;
		IToken signatureEllipsis = null;
		bool isTwoState = false;
		ExtremePredicate.KType kType = ExtremePredicate.KType.Unspecified;
		
		if (la.kind == 53) {
			Get();
			isTwoState = true; CheckAndSetTokenOnce(ref dmod.FirstToken); 
		}
		if (la.kind == 47) {
			Get();
			headToken = t; CheckAndSetTokenOnce(ref dmod.FirstToken); 
			if (la.kind == 68) {
				Get();
				functionMethodToken = t; 
			}
			while (la.kind == 83) {
				Attribute(ref attrs);
			}
			MethodFunctionName(out name);
			if (la.kind == 88 || la.kind == 90) {
				if (la.kind == 90) {
					GenericParameters(typeArgs, false);
				}
				Formals(true, true, isTwoState, true, formals);
				Expect(24);
				if (IsParenIdentsColon()) {
					Expect(88);
					GIdentType(false, false, false, false, out var range2, out var resultName, out var ty, out var resultIsGhost, out var isOld, out var isNameOnly, out var isOlder);
					Contract.Assert(!resultIsGhost && !isOld && !isNameOnly && !isOlder);
					result = new Formal(resultName.Tok, resultName.Value, ty, false, false, null, null, false)
					 { RangeToken = range2, IsTypeExplicit = ty != null };
					
					Expect(89);
				} else if (StartOf(5)) {
					Type(out returnType);
				} else SynErr(182);
			} else if (la.kind == 98) {
				Get();
				signatureEllipsis = t; 
			} else SynErr(183);
		} else if (la.kind == 48) {
			Get();
			headToken = t; isPredicate = true; CheckAndSetTokenOnce(ref dmod.FirstToken); 
			if (la.kind == 68) {
				Get();
				functionMethodToken = t; 
			}
			while (la.kind == 83) {
				Attribute(ref attrs);
			}
			MethodFunctionName(out name);
			if (la.kind == 86 || la.kind == 88 || la.kind == 90) {
				if (la.kind == 90) {
					GenericParameters(typeArgs, false);
				}
				if (la.kind == 86) {
					KType(ref kType, out IToken openBracket, out IToken closeBracket);
					SemErr(ErrorId.p_formal_ktype_only_in_least_and_greatest_predicates,
					      new RangeToken(openBracket, t), 
					      "a formal [ ] declaration is only allowed for least and greatest predicates");
					
				}
				Formals(true, true, isTwoState, true, formals);
				if (la.kind == 24) {
					PredicateResult("predicate", out result);
				}
			} else if (la.kind == 98) {
				Get();
				signatureEllipsis = t; 
			} else SynErr(184);
		} else if (la.kind == 49 || la.kind == 52) {
			Contract.Assert(!isTwoState);  // the IsFunctionDecl check checks that "twostate" is not followed by "least"
			
			if (la.kind == 49) {
				Get();
				CheckAndSetTokenOnce(ref dmod.FirstToken); 
			} else {
				Get();
				CheckAndSetTokenOnce(ref dmod.FirstToken); errors.Deprecated(ErrorId.p_deprecated_inductive_predicate, t, "the old keyword phrase 'inductive predicate' has been renamed to 'least predicate'"); 
			}
			Expect(48);
			isLeastPredicate = true; 
			while (la.kind == 83) {
				Attribute(ref attrs);
			}
			MethodFunctionName(out name);
			if (la.kind == 86 || la.kind == 88 || la.kind == 90) {
				if (la.kind == 90) {
					GenericParameters(typeArgs, false);
				}
				if (la.kind == 86) {
					KType(ref kType, out IToken openBracket, out IToken closeBracket);
				}
				Formals(true, false, false, false, formals);
				if (la.kind == 24) {
					PredicateResult("least predicate", out result);
				}
			} else if (la.kind == 98) {
				Get();
				signatureEllipsis = t; 
			} else SynErr(185);
		} else if (la.kind == 50 || la.kind == 54) {
			Contract.Assert(!isTwoState);  // the IsFunctionDecl check checks that "twostate" is not followed by "greatest"
			
			if (la.kind == 50) {
				Get();
				CheckAndSetTokenOnce(ref dmod.FirstToken); 
				Expect(48);
			} else {
				Get();
				CheckAndSetTokenOnce(ref dmod.FirstToken); errors.Deprecated(ErrorId.p_deprecated_copredicate, t, "the old keyword 'copredicate' has been renamed to the keyword phrase 'greatest predicate'"); 
			}
			isGreatestPredicate = true; 
			while (la.kind == 83) {
				Attribute(ref attrs);
			}
			MethodFunctionName(out name);
			if (la.kind == 86 || la.kind == 88 || la.kind == 90) {
				if (la.kind == 90) {
					GenericParameters(typeArgs, false);
				}
				if (la.kind == 86) {
					KType(ref kType, out IToken openBracket, out IToken closeBracket);
				}
				Formals(true, false, false, false, formals);
				if (la.kind == 24) {
					PredicateResult("greatest predicate", out result);
				}
			} else if (la.kind == 98) {
				Get();
				signatureEllipsis = t; 
			} else SynErr(186);
		} else SynErr(187);
		decreases = isLeastPredicate || isGreatestPredicate ? null : new List<Expression/*!*/>();
		tokenWithTrailingDocString = t;
		
		FunctionSpec(reqs, reads, ens, decreases, ref decAttrs, ref readsAttrs);
		IToken byMethodTok = null; BlockStmt byMethodBody = null; 
		if (la.kind == 84) {
			FunctionBody(out body, out bodyStart, out bodyEnd, out byMethodTok, out byMethodBody);
		}
		if (byMethodBody != null) {
		 /* ----- with "by method" ----- */
		 var what = isPredicate || isLeastPredicate || isGreatestPredicate ? "predicate" : "function";
		
		 if (isTwoState) {
		   var byrange = new RangeToken(byMethodTok, byMethodBody.EndToken);
		   SemErr(ErrorId.p_no_by_method_in_twostate, byrange, $"a 'by method' implementation is not allowed on a twostate {what}");
		   byMethodBody = null;
		   functionMethodToken = null; // to avoid a confusing error message below, drop the "method" keyword, if present
		
		 } else if (isLeastPredicate || isGreatestPredicate) {
		   var byrange = new RangeToken(byMethodTok, byMethodBody.EndToken);
		   SemErr(ErrorId.p_no_by_method_in_extreme_predicate, byrange, "a 'by method' implementation is not allowed on an extreme predicate");
		   byMethodBody = null;
		   functionMethodToken = null; // to avoid a confusing error message below, drop the "method" keyword, if present
		 }
		
		 /* Neither "ghost" nor "method" is allowed. After generating the appropriate error messages, update the
		  * "functionMethodToken" and "dmod" variables to erase having seen any illegal tokens.
		  */
		 if (functionMethodToken != null) {
		   SemErr(ErrorId.p_no_by_method_for_ghost_function, functionMethodToken,
		     $"to use a 'by method' implementation with a {what}, declare '{name.Value}' using '{what}', not '{what} method'");
		   functionMethodToken = null;
		 }
		 AllowedDeclModifiers allowed = AllowedDeclModifiers.AlreadyGhost | AllowedDeclModifiers.Static | AllowedDeclModifiers.Opaque;
		 CheckDeclModifiers(ref dmod, what + "-by-method", allowed);
		
		} else {
		 /* ----- without "by method" ----- */
		
		 var what = isPredicate ? "predicate" : "function";
		 if (isTwoState || isLeastPredicate || isGreatestPredicate) {
		   var adjective = isTwoState ? "twostate" : isLeastPredicate ? "least" : "greatest";
		
		   if (functionMethodToken != null) {
		     SemErr(ErrorId.p_twostate_and_extreme_are_always_ghost, functionMethodToken, $"a {adjective} {what} is supported only as ghost, not as a compiled {what}");
		     functionMethodToken = null;
		   }
		   AllowedDeclModifiers allowed = AllowedDeclModifiers.AlreadyGhost | AllowedDeclModifiers.Static | AllowedDeclModifiers.Opaque;
		   CheckDeclModifiers(ref dmod, $"{adjective} {what}", allowed);
		
		 } else {
		   // basic function or predicate
		   Contract.Assert(headToken != null);
		   if (functionMethodToken != null) {
		     if (isPredicate && theOptions.FunctionSyntax == FunctionSyntaxOptions.ExperimentalPredicateAlwaysGhost) {
		       SemErr(ErrorId.p_old_ghost_syntax, functionMethodToken, $"a {what} is always ghost and is declared with '{what}'");
		       functionMethodToken = null;
		       dmod.IsGhost = false; // don't report errors about 'ghost', too
		     } else if (theOptions.FunctionSyntax == FunctionSyntaxOptions.Version4 ||
		                theOptions.FunctionSyntax == FunctionSyntaxOptions.ExperimentalPredicateAlwaysGhost) {
		       var erange = new RangeToken(functionMethodToken.Prev, functionMethodToken);
		       if (isPredicate) {
		        SemErr(ErrorId.p_deprecating_predicate_method, erange, $"the phrase '{what} method' is not allowed when using --function-syntax:4; to declare a compiled {what}, use just '{what}'");
		       } else {
		        SemErr(ErrorId.p_deprecating_function_method, erange, $"the phrase '{what} method' is not allowed when using --function-syntax:4; to declare a compiled {what}, use just '{what}'");
		       }
		       functionMethodToken = null;
		     } else if (dmod.IsGhost && theOptions.FunctionSyntax != FunctionSyntaxOptions.Version3) {
		       var erange = new RangeToken(headToken, functionMethodToken);
		       if (isPredicate) {
		        SemErr(ErrorId.p_no_ghost_predicate_method, erange, $"there is no such thing as a 'ghost {what} method'");
		       } else {
		        SemErr(ErrorId.p_no_ghost_function_method, erange, $"there is no such thing as a 'ghost {what} method'");
		       }
		       functionMethodToken = null;
		     }
		   } else if (!dmod.IsGhost && theOptions.FunctionSyntax == FunctionSyntaxOptions.Migration3To4) {
		     SemErr(ErrorId.p_migration_syntax, headToken, $"a {what} must be declared as either 'ghost {what}' or '{what} method' when using --function-syntax:migration3to4");
		   }
		   AllowedDeclModifiers allowed = AllowedDeclModifiers.Static | AllowedDeclModifiers.Opaque;
		   if (isPredicate && theOptions.FunctionSyntax == FunctionSyntaxOptions.ExperimentalPredicateAlwaysGhost) {
		     allowed |= AllowedDeclModifiers.AlreadyGhost;
		   } else if (theOptions.FunctionSyntax == FunctionSyntaxOptions.Version3) {
		     allowed |= AllowedDeclModifiers.AlreadyGhost;
		   } else {
		     allowed |= AllowedDeclModifiers.Ghost;
		   }
		   CheckDeclModifiers(ref dmod, what, allowed);
		 }
		}
		
		/* ========================================
		* The 4 schemas have now been checked for legal combinations. In preparation for creating an AST node for
		* what was parsed, we determine if the function is considered ghost.
		* For our purposes here, a function-by-method is considered non-ghost.
		*/
		
		bool isGhost;
		if (isTwoState || isLeastPredicate || isGreatestPredicate) {
		 isGhost = true;
		} else if (byMethodBody != null) {
		 isGhost = false;
		} else {
		 switch (theOptions.FunctionSyntax) {
		   case FunctionSyntaxOptions.Version3:
		     isGhost = functionMethodToken == null;
		     break;
		   case FunctionSyntaxOptions.Migration3To4:
		   case FunctionSyntaxOptions.Version4:
		   case FunctionSyntaxOptions.ExperimentalTreatUnspecifiedAsCompiled:
		     isGhost = dmod.IsGhost;
		     break;
		   case FunctionSyntaxOptions.ExperimentalTreatUnspecifiedAsGhost:
		     isGhost = dmod.IsGhost || functionMethodToken == null;
		     break;
		   case FunctionSyntaxOptions.ExperimentalPredicateAlwaysGhost:
		     isGhost = dmod.IsGhost || isPredicate;
		     break;
		   default:
		     Contract.Assert(false); // unexpected FunctionSyntaxOptions
		     isGhost = false; // to please the compiler
		     break;
		 }
		}
		// Some sanity checks
		Contract.Assert(theOptions.FunctionSyntax != FunctionSyntaxOptions.Version4 || functionMethodToken == null);
		Contract.Assert(theOptions.FunctionSyntax != FunctionSyntaxOptions.Version3 || !dmod.IsGhost);
		Contract.Assert(byMethodBody == null || (functionMethodToken == null && !dmod.IsGhost));
		Contract.Assert(byMethodBody == null || !isGhost);
		
		/* ========================================
		* Having computed "isGhost" for whatever declaration we have parsed, we know whether or not to
		* allow formal parameters to be "ghost". So, as a last round of checking, we inspect the formal in-parameters
		* given in the signature. 
		*/
		
		if (isGhost) {
		 foreach (var formal in formals) {
		   if (formal.IsGhost) {
		     IToken t = formal.tok;
		     IToken ghostToken = null;
		     while (t != null && t.val != "," && t.val != "(") {
		      if (t.val == "ghost") {
		        ghostToken = t;
		        break;
		      }
		      t = t.Prev;
		     }
		     SemErr(ErrorId.p_no_ghost_formal, ghostToken ?? formal.tok, "formal cannot be declared 'ghost' in this context");
		   }
		 }
		}
		
		/* =========================================
		* Finally, we create the AST node for the function declaration we parsed.
		*/
		
		var range = new RangeToken(dmod.FirstToken, t);
		if (isTwoState && isPredicate) {
		 Contract.Assert(functionMethodToken == null && !dmod.IsGhost);
		 f = new TwoStatePredicate(range, name, dmod.IsStatic, dmod.IsOpaque, typeArgs, formals, result,
		                           reqs, new Specification<FrameExpression>(reads, readsAttrs), ens, new Specification<Expression>(decreases, decAttrs), body, attrs, signatureEllipsis);
		} else if (isTwoState) {
		 Contract.Assert(functionMethodToken == null && !dmod.IsGhost);
		 f = new TwoStateFunction(range, name, dmod.IsStatic, dmod.IsOpaque, typeArgs, formals, result, returnType,
		                          reqs, new Specification<FrameExpression>(reads, readsAttrs), ens, new Specification<Expression>(decreases, decAttrs), body, attrs, signatureEllipsis);
		} else if (isPredicate) {
		 Contract.Assert(functionMethodToken == null || !dmod.IsGhost);
		 f = new Predicate(range, name, dmod.IsStatic, isGhost, dmod.IsOpaque, typeArgs, formals, result,
		                   reqs, new Specification<FrameExpression>(reads, readsAttrs), ens, new Specification<Expression>(decreases, decAttrs), body, Predicate.BodyOriginKind.OriginalOrInherited,
		                   byMethodTok, byMethodBody, attrs, signatureEllipsis);
		} else if (isLeastPredicate) {
		 Contract.Assert(functionMethodToken == null && !dmod.IsGhost);
		 f = new LeastPredicate(range, name, dmod.IsStatic, dmod.IsOpaque, kType, typeArgs, formals, result,
		                        reqs, new Specification<FrameExpression>(reads, readsAttrs), ens, body, attrs, signatureEllipsis);
		} else if (isGreatestPredicate) {
		 Contract.Assert(functionMethodToken == null && !dmod.IsGhost);
		 f = new GreatestPredicate(range, name, dmod.IsStatic, dmod.IsOpaque, kType, typeArgs, formals, result,
		                           reqs, new Specification<FrameExpression>(reads, readsAttrs), ens, body, attrs, signatureEllipsis);
		} else {
		 Contract.Assert(functionMethodToken == null || !dmod.IsGhost);
		 f = new Function(range, name, dmod.IsStatic, isGhost, dmod.IsOpaque,
		                  typeArgs, formals, result, returnType,
		                  reqs, new Specification<FrameExpression>(reads, readsAttrs), ens, new Specification<Expression>(decreases, decAttrs), body,
		                  byMethodTok, byMethodBody,
		                  attrs, signatureEllipsis);
		}
		f.BodyStartTok = bodyStart;
		f.TokenWithTrailingDocString = tokenWithTrailingDocString;
		SystemModuleModifiers.Add(b => b.CreateArrowTypeDecl(formals.Count));
		if (isLeastPredicate || isGreatestPredicate) {
		 // also create an arrow type for the corresponding prefix predicate
		 SystemModuleModifiers.Add(b => b.CreateArrowTypeDecl(formals.Count + 1));
		}
		
	}

	void MethodDecl(DeclModifierData dmod, bool allowConstructor, out Method/*!*/ m) {
		Contract.Ensures(Contract.ValueAtReturn(out m) !=null);
		bool hasName = false;
		Name name = new Name("<noNameGiven>");  
		IToken keywordToken;
		Attributes attrs = null;
		List<TypeParameter/*!*/>/*!*/ typeArgs = new List<TypeParameter/*!*/>();
		List<Formal/*!*/> ins = new List<Formal/*!*/>();
		List<Formal/*!*/> outs = new List<Formal/*!*/>();
		List<AttributedExpression/*!*/> req = new List<AttributedExpression/*!*/>();
		List<FrameExpression/*!*/> reads = new List<FrameExpression/*!*/>();
		List<FrameExpression/*!*/> mod = new List<FrameExpression/*!*/>();
		List<AttributedExpression/*!*/> ens = new List<AttributedExpression/*!*/>();
		List<Expression/*!*/> dec = new List<Expression/*!*/>();
		Attributes decAttrs = null;
		Attributes modAttrs = null;
		Attributes readsAttrs = null;
		BlockStmt body = null;
		bool isPlainOlMethod = false;
		bool isLemma = false;
		bool isTwoStateLemma = false;
		bool isConstructor = false;
		bool isLeastLemma = false;
		bool isGreatestLemma = false;
		IToken signatureEllipsis = null;
		IToken tokenWithTrailingDocString = Token.NoToken;
		IToken bodyStart = Token.NoToken;
		IToken bodyEnd = Token.NoToken;
		AllowedDeclModifiers allowed = AllowedDeclModifiers.None;
		string caption = "";
		ExtremePredicate.KType kType = ExtremePredicate.KType.Unspecified;
		
		while (!(StartOf(12))) {SynErr(188); Get();}
		switch (la.kind) {
		case 68: {
			Get();
			isPlainOlMethod = true; caption = "method";
			CheckAndSetTokenOnce(ref dmod.FirstToken);
			allowed = AllowedDeclModifiers.Ghost | AllowedDeclModifiers.Static; 
			break;
		}
		case 55: {
			Get();
			isLemma = true; caption = "lemma";
			CheckAndSetTokenOnce(ref dmod.FirstToken);
			allowed = AllowedDeclModifiers.AlreadyGhost | AllowedDeclModifiers.Static; 
			break;
		}
		case 50: case 69: {
			if (la.kind == 50) {
				Get();
				CheckAndSetTokenOnce(ref dmod.FirstToken); 
				Expect(55);
			} else {
				Get();
				CheckAndSetTokenOnce(ref dmod.FirstToken); 
				errors.Deprecated(ErrorId.p_deprecated_colemma, t, "the old keyword 'colemma' has been renamed to the keyword phrase 'greatest lemma'"); 
				
			}
			isGreatestLemma = true; caption = "greatest lemma";
			allowed = AllowedDeclModifiers.AlreadyGhost | AllowedDeclModifiers.Static; 
			break;
		}
		case 49: case 52: {
			if (la.kind == 49) {
				Get();
				CheckAndSetTokenOnce(ref dmod.FirstToken); 
			} else {
				Get();
				CheckAndSetTokenOnce(ref dmod.FirstToken);
				errors.Deprecated(ErrorId.p_deprecated_inductive_lemma, t, "the old keyword phrase 'inductive lemma' has been renamed to 'least lemma'"); 
				
			}
			Expect(55);
			isLeastLemma = true;  caption = "least lemma";
			allowed = AllowedDeclModifiers.AlreadyGhost | AllowedDeclModifiers.Static;
			break;
		}
		case 53: {
			Get();
			CheckAndSetTokenOnce(ref dmod.FirstToken); 
			Expect(55);
			isTwoStateLemma = true; caption = "two-state lemma";
			allowed = AllowedDeclModifiers.AlreadyGhost | AllowedDeclModifiers.Static; 
			break;
		}
		case 70: {
			Get();
			CheckAndSetTokenOnce(ref dmod.FirstToken);
			if (allowConstructor) {
			 isConstructor = true;
			} else {
			 SemErr(ErrorId.p_constructor_not_in_class, t, "constructors are allowed only in classes");
			}
			caption = "constructor";
			allowed = AllowedDeclModifiers.Ghost;
			
			break;
		}
		default: SynErr(189); break;
		}
		keywordToken = t;
		CheckDeclModifiers(ref dmod, caption, allowed); 
		while (la.kind == 83) {
			Attribute(ref attrs);
		}
		if (StartOf(10)) {
			MethodFunctionName(out name);
			hasName = true; 
		}
		if (!hasName) {
		 if (!isConstructor) {
		   SemErr(ErrorId.p_method_missing_name, la, "a method must be given a name (expecting identifier)");
		 }
		}
		
		if (la.kind == 86 || la.kind == 88 || la.kind == 90) {
			if (la.kind == 90) {
				GenericParameters(typeArgs, false);
			}
			if (la.kind == 86) {
				KType(ref kType, out IToken openBracket, out IToken closeBracket);
				if (!(isGreatestLemma || isLeastLemma)) { 
				 // Note: When ranges are refactored, make the first use of openBracket a range
				 // that extends through closeBracket
				 SemErr(ErrorId.p_extraneous_k, 
				        new RangeToken(openBracket, closeBracket), 
				        "type of _k can only be specified for least and greatest lemmas"); 
				} 
				
			}
			var isCompilable = (isPlainOlMethod || isConstructor) && !dmod.IsGhost; 
			Formals(true, isCompilable, isTwoStateLemma, false, ins);
			if (la.kind == 113) {
				Get();
				var returnsToken = t; 
				Formals(false, isCompilable, false, false, outs);
				if (isConstructor) { SemErr(ErrorId.p_constructors_have_no_out_parameters, new RangeToken(returnsToken, t), "constructors cannot have out-parameters"); } 
			}
		} else if (la.kind == 98) {
			Get();
			signatureEllipsis = t; 
		} else SynErr(190);
		tokenWithTrailingDocString = t; 
		MethodSpec(dmod.IsGhost || isLemma || isTwoStateLemma || isLeastLemma || isGreatestLemma,
req, reads, mod, ens, dec, ref decAttrs, ref modAttrs, ref readsAttrs, caption, isConstructor);
		if (la.kind == 84) {
			if (isConstructor) {
				DividedBlockStmt dividedBody; 
				DividedBlockStmt(out dividedBody, out bodyStart, out bodyEnd);
				body = dividedBody; 
			} else {
				BlockStmt(out body, out bodyStart, out bodyEnd);
			}
		}
		var range = new RangeToken(dmod.FirstToken, t);
		if (isConstructor) {
		 m = new Constructor(range, hasName ? name : new Name(dmod.FirstToken.ToRange(), "_ctor"), dmod.IsGhost, typeArgs, ins,
		                     req, new Specification<FrameExpression>(reads, readsAttrs), new Specification<FrameExpression>(mod, modAttrs), ens, new Specification<Expression>(dec, decAttrs), (DividedBlockStmt)body, attrs, signatureEllipsis);
		} else if (isLeastLemma) {
		 m = new LeastLemma(range, name, dmod.IsStatic, kType, typeArgs, ins, outs,
		                    req, new Specification<FrameExpression>(reads, readsAttrs), new Specification<FrameExpression>(mod, modAttrs), ens, new Specification<Expression>(dec, decAttrs), body, attrs, signatureEllipsis);
		} else if (isGreatestLemma) {
		 m = new GreatestLemma(range, name, dmod.IsStatic, kType, typeArgs, ins, outs,
		                       req, new Specification<FrameExpression>(reads, readsAttrs), new Specification<FrameExpression>(mod, modAttrs), ens, new Specification<Expression>(dec, decAttrs), body, attrs, signatureEllipsis);
		} else if (isLemma) {
		 m = new Lemma(range, name, dmod.IsStatic, typeArgs, ins, outs,
		               req, new Specification<FrameExpression>(reads, readsAttrs), new Specification<FrameExpression>(mod, modAttrs), ens, new Specification<Expression>(dec, decAttrs), body, attrs, signatureEllipsis);
		} else if (isTwoStateLemma) {
		 m = new TwoStateLemma(range, name, dmod.IsStatic, typeArgs, ins, outs,
		                       req, new Specification<FrameExpression>(reads, readsAttrs), new Specification<FrameExpression>(mod, modAttrs),
		                       ens, new Specification<Expression>(dec, decAttrs), body, attrs, signatureEllipsis);
		} else {
		 m = new Method(range, name, dmod.IsStatic, dmod.IsGhost, typeArgs, ins, outs,
		                req, new Specification<FrameExpression>(reads, readsAttrs), new Specification<FrameExpression>(mod, modAttrs), ens, new Specification<Expression>(dec, decAttrs), body, attrs, signatureEllipsis);
		}
		m.BodyStartTok = bodyStart;
		m.TokenWithTrailingDocString = tokenWithTrailingDocString;
		
	}

	void DatatypeName(out Name name) {
		Name(out name);
	}

	void DatatypeMemberDecl(List<DatatypeCtor/*!*/>/*!*/ ctors) {
		Contract.Requires(cce.NonNullElements(ctors));
		Attributes attrs = null;
		IToken/*!*/ id;
		List<Formal/*!*/> formals = new List<Formal/*!*/>();
		var isGhost = false;
		
		if (la.kind == 75) {
			Get();
			isGhost = true; 
		}
		while (la.kind == 83) {
			Attribute(ref attrs);
		}
		DatatypeMemberName(out id);
		if (la.kind == 88) {
			FormalsOptionalIds(formals);
		}
		var ctor = new DatatypeCtor(new RangeToken(id, t), new Name(id), isGhost, formals, attrs);
		ctors.Add(ctor); 
	}

	void TypeMembers(ModuleDefinition/*!*/ module, List<MemberDecl> members ) {
		DeclModifierData dmod;
		
		Expect(84);
		while (StartOf(3)) {
			dmod = new DeclModifierData(); 
			while (StartOf(2)) {
				DeclModifier(ref dmod);
			}
			ClassMemberDecl(dmod, members, false, false);
		}
		Expect(85);
	}

	void DatatypeMemberName(out IToken id) {
		NoUSIdentOrDigits(out id);
	}

	void FormalsOptionalIds(List<Formal/*!*/>/*!*/ formals) {
		Contract.Requires(cce.NonNullElements(formals));
		RangeToken/*!*/ range;  Type/*!*/ ty;  Name/*!*/ name;  bool isGhost;  Expression/*?*/ defaultValue;
		bool isNameOnly;
		Attributes attributes;
		
		Expect(88);
		if (StartOf(13)) {
			TypeIdentOptional(out range, out name, out ty, out isGhost, out defaultValue, out isNameOnly, out attributes);
			formals.Add(new Formal(name.Tok, name.Value, ty, true, isGhost, defaultValue, attributes, false, isNameOnly) 
			    { RangeToken = range, IsTypeExplicit = ty != null}
			); 
			
			while (la.kind == 25) {
				Get();
				TypeIdentOptional(out range, out name, out ty, out isGhost, out defaultValue, out isNameOnly, out attributes);
				formals.Add(new Formal(name.Tok, name.Value, ty, true, isGhost, defaultValue, attributes, false, isNameOnly)
				    { RangeToken = range, IsTypeExplicit = ty != null}
				); 
				
			}
		}
		Expect(89);
	}

	void FIdentType(out Name/*!*/ name, out Type/*!*/ ty) {
		NoDigitName(out name);
		ty = null; 
		if (la.kind == 24) {
			Get();
			Type(out ty);
		} else if (StartOf(14)) {
			SemErr(ErrorId.p_var_decl_must_have_type, t, "a mutable field must be declared with a type"); 
		} else SynErr(191);
		if (la.kind == 28 || la.kind == 92) {
			if (la.kind == 28) {
				Get();
			} else {
				Get();
			}
			var optoken = t; Expression e; 
			Expression(out e, true, true);
			var erange = new RangeToken(optoken, e.EndToken);
			SemErr(ErrorId.p_no_init_for_var_field, erange, "a mutable field may not have an initializer"); 
			
		}
	}

	void OldSemi() {
		if (la.kind == 32) {
			while (!(la.kind == 0 || la.kind == 32)) {SynErr(192); Get();}
			Get();
			errors.Deprecated(ErrorId.p_deprecated_semicolon, t, "deprecated style: a semi-colon is not needed here"); 
		}
	}

	void CIdentType(out Name/*!*/ name, out Type ty) {
		Contract.Ensures(Contract.ValueAtReturn(out name) != null);
		ty = null;
		
		NoDigitName(out name);
		if (la.kind == 24) {
			Get();
			Type(out ty);
		}
	}

	void Expression(out Expression e, bool allowLemma, bool allowLambda, bool allowBitwiseOps = true) {
		Expression e0; IToken semiToken; 
		if (la.kind == 79) {
			Get();
			SemErr(ErrorId.p_no_side_effects_in_expressions, t, "Calls with side-effects such as constructors are not allowed in expressions."); 
		}
		EquivExpression(out e, allowLemma, allowLambda, allowBitwiseOps);
		if (SemiFollowsCall(allowLemma, e)) {
			Expect(32);
			Console.WriteLine("INSIDE SEMI FOLLOWS CALL:");
			semiToken = t; 
			Expression(out e0, allowLemma, allowLambda);
			var startToken = e.StartToken;
			e = new StmtExpr(e0.Tok,
			     new UpdateStmt(e.RangeToken, new List<Expression>(), new List<AssignmentRhs>() { new ExprRhs(e) }),
			     e0);
			e.RangeToken = new RangeToken(startToken, e0.EndToken);
			
		}
	}

	void NewtypeName(out Name name) {
		Name(out name);
	}

	void LocalVarName(out IToken id) {
		NoUSIdent(out id);
	}

	void NoUSIdent(out IToken/*!*/ x) {
		Contract.Ensures(Contract.ValueAtReturn(out x) != null); 
		Ident(out x);
		if (x.val.StartsWith("_")) {
		 SemErr(ErrorId.p_no_leading_underscore_2, x, 
		   "cannot declare identifier beginning with underscore");
		}
		
	}

	void SynonymTypeName(out Name name) {
		Name(out name);
	}

	void TypeParameterCharacteristics(ref TypeParameter.TypeParameterCharacteristics characteristics) {
		Expect(88);
		var startToken = t; 
		TPCharOption(ref characteristics);
		while (la.kind == 25) {
			Get();
			TPCharOption(ref characteristics);
		}
		Expect(89);
		characteristics.RangeToken = new RangeToken(startToken, t); 
	}

	void GIdentType(bool allowGhostKeyword, bool allowNewKeyword, bool allowNameOnlyKeyword, bool allowOlderKeyword,
out RangeToken range, out Name/*!*/ name, out Type/*!*/ ty, out bool isGhost, out bool isOld, out bool isNameOnly, out bool isOlder) {
		Contract.Ensures(Contract.ValueAtReturn(out name)!=null);
		Contract.Ensures(Contract.ValueAtReturn(out ty)!=null);
		isGhost = false; isOld = allowNewKeyword; isNameOnly = false; isOlder = false;
		IToken startToken = t.Next;
		
		while (IsKeywordForFormal()) {
			if (la.kind == 75) {
				Get();
				if (allowGhostKeyword) { isGhost = true; } else { SemErr(ErrorId.p_output_of_function_not_ghost, t, "formal cannot be declared 'ghost' in this context"); } 
			} else if (la.kind == 79) {
				Get();
				if (allowNewKeyword) { isOld = false; } else { SemErr(ErrorId.p_no_new_on_output_formals, t, "formal cannot be declared 'new' in this context"); } 
			} else if (la.kind == 80) {
				Get();
				if (allowNameOnlyKeyword) { isNameOnly = true; } else { SemErr(ErrorId.p_no_nameonly_on_output_formals, t, "formal cannot be declared 'nameonly' in this context"); } 
			} else if (la.kind == 81) {
				Get();
				if (allowOlderKeyword) { isOlder = true; } else { SemErr(ErrorId.p_no_older_on_output_formals, t, "formal cannot be declared 'older' in this context"); } 
			} else SynErr(193);
		}
		IdentType(out var id, out var originalId, out ty, false);
		range = new RangeToken(startToken, ty.EndToken);
		name = new Name(id);
		
	}

	void IdentType(out IToken/*!*/ id, out IToken originalId, out Type/*!*/ ty, bool allowWildcardId) {
		Contract.Ensures(Contract.ValueAtReturn(out id) != null); Contract.Ensures(Contract.ValueAtReturn(out ty) != null);
		WildIdent(out id, allowWildcardId);
		originalId = t; 
		Expect(24);
		Type(out ty);
	}

	void NoDigitName(out Name x) {
		IToken t; 
		NoUSIdentOrDigits(out t);
		x = new Name(t); 
	}

	void WildIdent(out IToken x, bool allowWildcardId) {
		Contract.Ensures(Contract.ValueAtReturn(out x) != null); 
		Ident(out x);
		x = t.WithVal(UnwildIdent(t, allowWildcardId)); 
	}

	void LocalIdentTypeOptional(out LocalVariable var, bool isGhost, bool allowWild=true) {
		IToken id;  Type ty;  Type optType = null;
		IToken startToken = null;
		
		WildIdent(out id, allowWild);
		startToken = t; 
		if (la.kind == 24) {
			Get();
			Type(out ty);
			optType = ty; 
		}
		var = new LocalVariable(new RangeToken(startToken, t), id.val, optType == null ? new InferredTypeProxy() : optType, isGhost) {
		 IsTypeExplicit = optType != null
		};
		
	}

	void IdentTypeOptional(out BoundVar var) {
		Contract.Ensures(Contract.ValueAtReturn(out var) != null);
		Type ty;  Type optType = null;
		
		WildIdentN(out var name, true);
		if (la.kind == _colon) {
			Expect(24);
			Type(out ty);
			optType = ty; 
		}
		var = new BoundVar(name.Tok, name.Value, optType == null ? new InferredTypeProxy() : optType) {
		 IsTypeExplicit = optType != null,
		 RangeToken = new RangeToken(name.StartToken, t)
		}; 
	}

	void WildIdentN(out Name name, bool allowWildcardId) {
		WildIdent(out var x, allowWildcardId);
		name = new Name(x); 
	}

	void TypeIdentOptional(out RangeToken/*!*/ range, out Name/*!*/ identName, out Type/*!*/ ty, 
out bool isGhost, out Expression defaultValue, out bool isNameOnly, out Attributes attributes) {
		Contract.Ensures(Contract.ValueAtReturn(out range)!=null);
		Contract.Ensures(Contract.ValueAtReturn(out ty)!=null);
		Contract.Ensures(Contract.ValueAtReturn(out identName)!=null);
		IToken nameToken = null; ty = new BoolType()/*dummy*/; isGhost = false;
		IToken nameonlyToken = null;
		attributes = null;
		identName = null;
		defaultValue = null;
		
		var beforeStartToken = t; 
		while (la.kind == 83) {
			Attribute(ref attributes);
		}
		while (la.kind == 75 || la.kind == 80) {
			if (la.kind == 75) {
				Get();
				isGhost = true; 
			} else {
				Get();
				nameonlyToken = t; 
			}
		}
		if (StartOf(5)) {
			TypeAndToken(out var firstToken, out ty, false);
			if (la.kind == 24) {
				Get();
				UserDefinedType udt = ty as UserDefinedType;
				if (udt != null && udt.TypeArgs.Count == 0) {
				 nameToken = firstToken;
				} else {
				 SemErr(ErrorId.p_datatype_formal_is_not_id, firstToken, "invalid formal-parameter name in datatype constructor");
				}
				
				Type(out ty);
				ParameterDefaultValue(true, out defaultValue);
			}
		} else if (la.kind == 2) {
			Get();
			nameToken = t; 
			Expect(24);
			Type(out ty);
			ParameterDefaultValue(true, out defaultValue);
		} else SynErr(194);
		range = new RangeToken(beforeStartToken.Next, t);
		if (nameToken != null) {
		 identName = new Name(nameToken);
		 isNameOnly = nameonlyToken != null;
		} else {
		 identName = new Name(range, "#" + anonymousIds++);
		 if (nameonlyToken != null) {
		   SemErr(ErrorId.p_nameonly_must_have_parameter_name, nameonlyToken, "use of the 'nameonly' modifier must be accompanied with a parameter name");
		 }
		 isNameOnly = false;
		}
		
	}

	void TypeAndToken(out IToken tok, out Type ty, bool inExpressionContext) {
		Contract.Ensures(Contract.ValueAtReturn(out tok)!=null);
		Contract.Ensures(Contract.ValueAtReturn(out ty) != null);
		tok = Token.NoToken;
		ty = new BoolType();  /*keep compiler happy*/
		IToken startToken = null;
		List<Type> gt;
		List<Type> tupleArgTypes = null;
		List<IToken> argumentGhostTokens = null;
		
		switch (la.kind) {
		case 7: {
			Get();
			tok = t; startToken = t; 
			break;
		}
		case 8: {
			Get();
			tok = t; startToken = t;  ty = new CharType(); 
			break;
		}
		case 9: {
			Get();
			tok = t; startToken = t;  ty = new IntType(); 
			break;
		}
		case 10: {
			Get();
			tok = t; startToken = t;  ty = new UserDefinedType(tok, tok.val, null); 
			break;
		}
		case 11: {
			Get();
			tok = t; startToken = t;  ty = new RealType(); 
			break;
		}
		case 12: {
			Get();
			tok = t; startToken = t;  ty = new BigOrdinalType(); 
			break;
		}
		case 6: {
			Get();
			tok = t; startToken = t;
			int w = StringToInt(tok.val.Substring(2), 0, "bitvectors that wide", startToken);
			ty = new BitvectorType(theOptions, w);
			
			break;
		}
		case 16: {
			Get();
			tok = t; startToken = t; 
			OptGenericInstantiation(out gt, inExpressionContext);
			if (gt != null && gt.Count > 1) {
			 SemErr(ErrorId.p_set_only_one_type_parameter, 
			   new RangeToken(startToken.Next, t), "set type expects only one type argument");
			}
			ty = new SetType(true, gt != null ?gt[0] : null);
			
			break;
		}
		case 17: {
			Get();
			tok = t; startToken = t; 
			OptGenericInstantiation(out gt, inExpressionContext);
			if (gt != null && gt.Count > 1) {
			 SemErr(ErrorId.p_iset_only_one_type_parameter, 
			   new RangeToken(startToken.Next, t), "iset type expects only one type argument");
			}
			ty = new SetType(false, gt != null ? gt[0] : null);
			
			break;
		}
		case 18: {
			Get();
			tok = t; startToken = t; 
			OptGenericInstantiation(out gt, inExpressionContext);
			if (gt != null && gt.Count > 1) {
			 SemErr(ErrorId.p_multiset_only_one_type_parameter, 
			   new RangeToken(startToken.Next, t), "multiset type expects only one type argument");
			}
			ty = new MultiSetType(gt != null ? gt[0] : null);
			
			break;
		}
		case 19: {
			Get();
			tok = t; startToken = t; 
			OptGenericInstantiation(out gt, inExpressionContext);
			if (gt != null && gt.Count > 1) {
			 SemErr(ErrorId.p_seq_only_one_type_parameter, 
			   new RangeToken(startToken.Next, t), "seq type expects only one type argument");
			}
			ty = new SeqType(gt != null ? gt[0] : null);
			
			break;
		}
		case 15: {
			Get();
			tok = t; startToken = t;  ty = new UserDefinedType(tok, tok.val, null); 
			break;
		}
		case 13: {
			Get();
			tok = t; startToken = t;  ty = new UserDefinedType(tok, tok.val, null); 
			break;
		}
		case 14: {
			Get();
			tok = t; startToken = t;  ty = new UserDefinedType(tok, tok.val, null); 
			break;
		}
		case 20: {
			Get();
			tok = t; startToken = t; 
			OptGenericInstantiation(out gt, inExpressionContext);
			if (gt == null) {
			 ty = new MapType(true, null, null);
			} else if (gt.Count != 2) {
			 SemErr(ErrorId.p_map_needs_two_type_parameters, 
			   new RangeToken(startToken.Next, t), "map type expects two type arguments");
			 ty = new MapType(true, gt[0], gt.Count == 1 ? new InferredTypeProxy() : gt[1]);
			} else {
			 ty = new MapType(true, gt[0], gt[1]);
			}
			
			break;
		}
		case 21: {
			Get();
			tok = t; startToken = t; 
			OptGenericInstantiation(out gt, inExpressionContext);
			if (gt == null) {
			 ty = new MapType(false, null, null);
			} else if (gt.Count != 2) {
			 SemErr(ErrorId.p_imap_needs_two_type_parameters, 
			   new RangeToken(startToken.Next, t), "imap type expects two type arguments");
			 ty = new MapType(false, gt[0], gt.Count == 1 ? new InferredTypeProxy() : gt[1]);
			} else {
			 ty = new MapType(false, gt[0], gt[1]);
			}
			
			break;
		}
		case 5: {
			Get();
			tok = t; startToken = t; 
			OptGenericInstantiation(out gt, inExpressionContext);
			var tokString = tok.val;
			bool q = tokString[tokString.Length-1] == '?';
			// Extracting the dimension out of array2 or array10?
			var dimString = tokString.Substring(5, tokString.Length - (q?6:5)); // 5 is length of "array"
			int dims = StringToInt(dimString, 1, "arrays of that many dimensions", startToken);
			(ty, var bMod) = SystemModuleManager.ArrayType(tok, dims, gt, true, q);
			SystemModuleModifiers.Add(bMod);
			
			break;
		}
		case 88: {
			TupleType(out ty, out tok, out tupleArgTypes, out argumentGhostTokens);
			break;
		}
		case 1: case 49: case 50: case 51: case 81: {
			NamedType(out ty, out tok, inExpressionContext);
			break;
		}
		default: SynErr(195); break;
		}
		startToken = startToken ?? ty.StartToken ?? tok;
		ty.RangeToken = new RangeToken(startToken, t);
		
		if (la.kind == 101 || la.kind == 102 || la.kind == 103) {
			int arrowKind = 0; /* 0: any, 1: partial, 2: total */
			Type t2;
			
			if (la.kind == 102) {
				Get();
				arrowKind = 0; 
			} else if (la.kind == 103) {
				Get();
				arrowKind = 1; 
			} else {
				Get();
				arrowKind = 2; 
			}
			tok = t; 
			Type(out t2);
			if (tupleArgTypes == null) {
			 gt = new List<Type>{ ty };
			} else {
			 // make sure no "ghost" keyword was used in the tuple-looking type
			 foreach (var ghostToken in argumentGhostTokens.Where(ghostToken => ghostToken != null)) {
			   SemErr(ErrorId.p_no_ghost_arrow_type_arguments, ghostToken, $"arrow-type arguments may not be declared as 'ghost'");
			 }
			 gt = tupleArgTypes;
			}
			var arity = gt.Count;
			SystemModuleModifiers.Add(b => b.CreateArrowTypeDecl(arity));
			if (arrowKind == 0) {
			 ty = new ArrowType(tok, gt, t2);
			} else {
			 gt.Add(t2);
			 if (arrowKind == 1) {
			   ty = new UserDefinedType(tok, ArrowType.PartialArrowTypeName(arity), gt);
			 } else {
			   ty = new UserDefinedType(tok, ArrowType.TotalArrowTypeName(arity), gt);
			 }
			}
			ty.RangeToken = new RangeToken(startToken, t);
			
		}
	}

	void ParameterDefaultValue(bool incoming, out Expression defaultValue) {
		defaultValue = null; IToken tok;
		
		if (la.kind == 28) {
			Get();
			tok = t; 
			Expression(out defaultValue, true, true);
			if (!incoming) {
			 SemErr(ErrorId.p_no_defaults_for_out_parameters, new RangeToken(tok,t), "out-parameters cannot have default-value expressions");
			 defaultValue = null;
			}
			
		}
	}

	void IteratorName(out Name name) {
		Name(out name);
	}

	void Formals(bool incoming, bool allowGhostKeyword, bool allowNewKeyword, bool allowOlderKeyword, List<Formal> formals) {
		Contract.Requires(cce.NonNullElements(formals));
		Type ty;
		bool isGhost;
		bool isOld;
		Expression defaultValue;
		bool isNameOnly;
		bool isOlder;
		Attributes attributes = null;
		RangeToken range;
		Name name;
		
		Expect(88);
		if (StartOf(15)) {
			while (la.kind == 83) {
				Attribute(ref attributes);
			}
			GIdentType(allowGhostKeyword, allowNewKeyword, incoming, allowOlderKeyword, out range, out name, out ty, out isGhost, out isOld, out isNameOnly, out isOlder);
			ParameterDefaultValue(incoming, out defaultValue);
			formals.Add(new Formal(name.Tok, name.Value, ty, incoming, isGhost, defaultValue, attributes, isOld, isNameOnly, isOlder)
			   { RangeToken = defaultValue != null ? new RangeToken(range.StartToken, defaultValue.EndToken) : range, IsTypeExplicit = ty != null }
			); 
			while (la.kind == 25) {
				Get();
				while (la.kind == 83) {
					Attribute(ref attributes);
				}
				GIdentType(allowGhostKeyword, allowNewKeyword, incoming, allowOlderKeyword, out range, out name, out ty, out isGhost, out isOld, out isNameOnly, out isOlder);
				ParameterDefaultValue(incoming, out defaultValue);
				formals.Add(new Formal(name.Tok, name.Value, ty, incoming, isGhost, defaultValue, attributes, isOld, isNameOnly, isOlder)
				   { RangeToken = defaultValue != null ? new RangeToken(range.StartToken, defaultValue.EndToken) : range, IsTypeExplicit = ty != null }
				); 
			}
		}
		Expect(89);
	}

	void IteratorSpec(List<FrameExpression/*!*/>/*!*/ reads, List<FrameExpression/*!*/>/*!*/ mod, List<Expression/*!*/> decreases,
List<AttributedExpression/*!*/>/*!*/ req, List<AttributedExpression/*!*/>/*!*/ ens,
List<AttributedExpression/*!*/>/*!*/ yieldReq, List<AttributedExpression/*!*/>/*!*/ yieldEns,
ref Attributes readsAttrs, ref Attributes modAttrs, ref Attributes decrAttrs) {
		while (!(StartOf(16))) {SynErr(196); Get();}
		while (StartOf(17)) {
			if (la.kind == 72) {
				ReadsClause(reads, ref readsAttrs, false, false, false);
			} else if (la.kind == 71) {
				ModifiesClause(ref mod, ref modAttrs, false, false);
			} else if (la.kind == 73 || la.kind == 74 || la.kind == 116) {
				bool isYield = false; 
				if (la.kind == 116) {
					Get();
					isYield = true; 
				}
				if (la.kind == 73) {
					RequiresClause((isYield?yieldReq:req), !isYield);
				} else if (la.kind == 74) {
					EnsuresClause((isYield?yieldEns:ens), false);
				} else SynErr(197);
			} else {
				DecreasesClause(decreases, ref decrAttrs, false, false);
			}
		}
	}

	void BlockStmt(out BlockStmt/*!*/ block, out IToken bodyStart, out IToken bodyEnd) {
		Contract.Ensures(Contract.ValueAtReturn(out block) != null);
		List<Statement/*!*/> body = new List<Statement/*!*/>();
		
		Expect(84);
		bodyStart = t; 
		while (StartOf(18)) {
			Stmt(body);
		}
		Expect(85);
		bodyEnd = t;
		block = new BlockStmt(new RangeToken(bodyStart, bodyEnd), body);
		
	}

	void TypeVariableName(out Name name) {
		Name(out name);
	}

	void Variance(out TypeParameter.TPVarianceSyntax variance) {
		variance = TypeParameter.TPVarianceSyntax.NonVariant_Strict;  // never used; here just to please the C# compiler
		
		if (la.kind == 95) {
			Get();
			variance = TypeParameter.TPVarianceSyntax.Covariant_Permissive; 
		} else if (la.kind == 114) {
			Get();
			variance = TypeParameter.TPVarianceSyntax.Covariant_Strict; 
		} else if (la.kind == 115) {
			Get();
			variance = TypeParameter.TPVarianceSyntax.NonVariant_Permissive; 
		} else if (la.kind == 104) {
			Get();
			variance = TypeParameter.TPVarianceSyntax.Contravariance; 
		} else SynErr(198);
	}

	void TPCharOption(ref TypeParameter.TypeParameterCharacteristics characteristics) {
		if (la.kind == 93) {
			Get();
			characteristics.EqualitySupport = TypeParameter.EqualitySupportValue.Required; 
		} else if (la.kind == 2) {
			Get();
			if (t.val == "0") {
			 characteristics.AutoInit = Microsoft.Dafny.Type.AutoInitInfo.CompilableValue;
			} else if (t.val == "00") {
			 if (characteristics.AutoInit != Microsoft.Dafny.Type.AutoInitInfo.CompilableValue) {
			   characteristics.AutoInit = Microsoft.Dafny.Type.AutoInitInfo.Nonempty;
			 }
			} else {
			 SemErr(ErrorId.p_unexpected_type_characteristic, t, $"unexpected type characteristic: '{t.val}' should be one of == or 0 or 00 or !new");
			}
			
		} else if (la.kind == 115) {
			Get();
			Expect(79);
			characteristics.ContainsNoReferenceTypes = true; 
		} else if (StartOf(19)) {
			Get();
			if (t.kind == _closeparen || t.kind == _comma) 
			   SemErr(ErrorId.p_missing_type_characteristic, t, $"extra comma or missing type characteristic: should be one of == or 0 or 00 or !new");
			else SemErr(ErrorId.p_illegal_type_characteristic, t, $"illegal type characteristic: '{t.val}' should be one of == or 0 or 00 or !new");
			
		} else SynErr(199);
	}

	void MethodFunctionName(out Name name) {
		NoDigitName(out name);
	}

	void KType(ref ExtremePredicate.KType kType, out IToken openBracket, out IToken closeBracket) {
		Expect(86);
		openBracket = t; 
		if (la.kind == 10) {
			Get();
			kType = ExtremePredicate.KType.Nat; 
		} else if (la.kind == 12) {
			Get();
			kType = ExtremePredicate.KType.ORDINAL; 
		} else SynErr(200);
		Expect(87);
		closeBracket = t; 
	}

	void MethodSpec(bool isGhost, List<AttributedExpression> req, List<FrameExpression> reads, List<FrameExpression> mod, List<AttributedExpression> ens,
List<Expression> decreases, ref Attributes decAttrs, ref Attributes modAttrs, ref Attributes readsAttrs, string caption, bool performThisDeprecatedCheck) {
		Contract.Requires(cce.NonNullElements(req));
		Contract.Requires(cce.NonNullElements(reads));
		Contract.Requires(cce.NonNullElements(mod));
		Contract.Requires(cce.NonNullElements(ens));
		Contract.Requires(cce.NonNullElements(decreases));
		
		while (!(StartOf(20))) {SynErr(201); Get();}
		while (StartOf(21)) {
			if (la.kind == 72) {
				ReadsClause(reads, ref readsAttrs, false, false, true);
			} else if (la.kind == 71) {
				ModifiesClause(ref mod, ref modAttrs, false, performThisDeprecatedCheck);
			} else if (la.kind == 73) {
				RequiresClause(req, true);
			} else if (la.kind == 74) {
				EnsuresClause(ens, false);
			} else {
				DecreasesClause(decreases, ref decAttrs, !isGhost, false);
			}
		}
	}

	void DividedBlockStmt(out DividedBlockStmt body, out IToken bodyStart, out IToken bodyEnd) {
		Contract.Ensures(Contract.ValueAtReturn(out body) != null);
		List<Statement> bodyInit = new List<Statement>();
		IToken separatorTok = null;
		List<Statement> bodyProper = new List<Statement>();
		
		Expect(84);
		bodyStart = t; 
		while (StartOf(18)) {
			Stmt(bodyInit);
		}
		if (la.kind == 79) {
			Get();
			separatorTok = t; 
			Expect(32);
			while (StartOf(18)) {
				Stmt(bodyProper);
			}
		}
		Expect(85);
		bodyEnd = t; 
		body = new DividedBlockStmt(new RangeToken(bodyStart, t), bodyInit, separatorTok, bodyProper); 
	}

	void RequiresClause(List<AttributedExpression> req, bool allowLabel) {
		Expect(73);
		IToken lbl = null;
		IToken first = t;
		Attributes attrs = null;
		Expression e;
		
		while (la.kind == 83) {
			Attribute(ref attrs);
		}
		if (IsLabel(allowLabel)) {
			LabelName(out lbl);
			Expect(24);
		}
		Expression(out e, false, false);
		OldSemi();
		req.Add(new AttributedExpression(e, lbl == null ? null : new AssertLabel(lbl, lbl.val), attrs)); 
	}

	void LabelName(out IToken id) {
		NoUSIdentOrDigits(out id);
	}

	void EnsuresClause(List<AttributedExpression> ens, bool allowLambda) {
		Expect(74);
		Expression e;
		Attributes attrs = null;
		
		while (la.kind == 83) {
			Attribute(ref attrs);
		}
		Expression(out e, false, allowLambda);
		OldSemi();
		ens.Add(new AttributedExpression(e, attrs)); 
	}

	void ModifiesClause(ref List<FrameExpression> mod, ref Attributes attrs,
bool allowLambda, bool performThisDeprecatedCheck) {
		Expect(71);
		FrameExpression fe;
		mod = mod ?? new List<FrameExpression>();
		
		while (la.kind == 83) {
			Attribute(ref attrs);
		}
		FrameExpression(out fe, false, allowLambda);
		Util.AddFrameExpression(mod, fe, performThisDeprecatedCheck, errors); 
		while (la.kind == 25) {
			Get();
			FrameExpression(out fe, false, allowLambda);
			Util.AddFrameExpression(mod, fe, performThisDeprecatedCheck, errors); 
		}
		OldSemi();
	}

	void FrameExpression(out FrameExpression fe, bool allowLemma, bool allowLambda) {
		Contract.Ensures(Contract.ValueAtReturn(out fe) != null);
		Expression/*!*/ e;
		IToken/*!*/ id;
		string fieldName = null;
		IToken feTok = null;
		fe = dummyFrameExpr;
		
		if (StartOf(4)) {
			Expression(out e, allowLemma, allowLambda);
			feTok = e.tok; 
			if (la.kind == 31) {
				FrameField(out id);
				fieldName = id.val;  feTok = id; 
			}
			fe = new FrameExpression(feTok, e, fieldName); 
		} else if (la.kind == 31) {
			FrameField(out id);
			fieldName = id.val; 
			fe = new FrameExpression(id, new ImplicitThisExpr(id), fieldName); 
		} else SynErr(202);
	}

	void DecreasesClause(List<Expression> decreases, ref Attributes attrs,
bool allowWildcard, bool allowLambda) {
		Expect(44);
		while (la.kind == 83) {
			Attribute(ref attrs);
		}
		DecreasesList(decreases, allowWildcard, allowLambda);
		OldSemi();
	}

	void DecreasesList(List<Expression> decreases, bool allowWildcard, bool allowLambda) {
		Expression e; 
		PossiblyWildExpression(out e, allowLambda, allowWildcard);
		decreases.Add(e); 
		while (la.kind == 25) {
			Get();
			PossiblyWildExpression(out e, allowLambda, allowWildcard);
			decreases.Add(e); 
		}
		if (allowWildcard && decreases.Count > 1 && decreases.Exists(e => e is WildcardExpr)) {
		 SemErr(ErrorId.p_no_decreases_expressions_with_star, e.tok, "A 'decreases' clause that contains '*' is not allowed to contain any other expressions");
		}
		
	}

	void ReadsClause(List<FrameExpression/*!*/>/*!*/ reads, ref Attributes attrs,
    bool allowLemma, bool allowLambda, bool allowWild) {
		Expect(72);
		FrameExpression fe; 
		while (la.kind == 83) {
			Attribute(ref attrs);
		}
		PossiblyWildFrameExpression(out fe, allowLemma, allowLambda, allowWild);
		reads.Add(fe); 
		while (la.kind == 25) {
			Get();
			PossiblyWildFrameExpression(out fe, allowLemma, allowLambda, allowWild);
			reads.Add(fe); 
		}
		if (allowWild && reads.Count > 1 && reads.Exists(fe => fe.E is WildcardExpr)) {
		 SemErr(ErrorId.p_reads_star_must_be_alone, reads.First(fe => fe.E is WildcardExpr).tok, "A 'reads' clause that contains '*' is not allowed to contain any other expressions");
		}
		
		OldSemi();
	}

	void PossiblyWildFrameExpression(out FrameExpression fe, bool allowLemma,
bool allowLambda, bool allowWild) {
		Contract.Ensures(Contract.ValueAtReturn(out fe) != null); fe = dummyFrameExpr; 
		if (la.kind == 95) {
			Get();
			fe = new FrameExpression(t, new WildcardExpr(t), null);
			if (!allowWild) {
			  SemErr(ErrorId.p_no_wild_frame_expression, t, "A '*' frame expression is not permitted here");
			}
			
		} else if (StartOf(22)) {
			FrameExpression(out fe, allowLemma, allowLambda);
		} else SynErr(203);
	}

	void InvariantClause(List<AttributedExpression> invariants) {
		Expect(46);
		Attributes attrs = null;
		Expression e;
		
		while (la.kind == 83) {
			Attribute(ref attrs);
		}
		Expression(out e, false, true);
		invariants.Add(new AttributedExpression(e, attrs)); 
		OldSemi();
	}

	void OptGenericInstantiation(out List<Type> gt, bool inExpressionContext) {
		gt = null; 
		if (IsGenericInstantiation(inExpressionContext)) {
			gt = new List<Type>(); 
			GenericInstantiation(gt);
		}
	}

	void TupleType(out Type ty, out IToken tok, out List<Type> tupleArgTypes, out List<IToken> argumentGhostTokens) {
		Expect(88);
		tok = t;
		ty = null; // To keep compiler happy
		tupleArgTypes = new List<Type>();
		IToken ghostToken = null;
		argumentGhostTokens = new List<IToken>();
		
		if (StartOf(23)) {
			if (la.kind == 75) {
				Get();
				ghostToken = t; 
			}
			Type(out ty);
			tupleArgTypes.Add(ty); argumentGhostTokens.Add(ghostToken); 
			while (la.kind == 25) {
				Get();
				ghostToken = null; 
				if (la.kind == 75) {
					Get();
					ghostToken = t; 
				}
				Type(out ty);
				tupleArgTypes.Add(ty); argumentGhostTokens.Add(ghostToken); 
			}
		}
		Expect(89);
		if (tupleArgTypes.Count == 1 && argumentGhostTokens[0] == null) {
		 // just return the type 'ty'
		} else {
		 var dims = tupleArgTypes.Count;
		 var argumentGhostness = argumentGhostTokens.ConvertAll(tok => tok != null);
		 var tokCopy = tok;
		 SystemModuleModifiers.Add(b => b.TupleType(tokCopy, dims, true, argumentGhostness));  // make sure the tuple type exists
		 ty = new UserDefinedType(tok, SystemModuleManager.TupleTypeName(argumentGhostness), dims == 0 ? null : tupleArgTypes);
		}
		
	}

	void NamedType(out Type ty, out IToken tok, bool inExpressionContext) {
		Expression e; IToken startToken = null; 
		NameSegmentForTypeName(out e, inExpressionContext);
		tok = t; startToken = e.StartToken; 
		while (la.kind == 30) {
			Get();
			TypeNameOrCtorSuffix(out tok);
			List<Type> typeArgs; 
			OptGenericInstantiation(out typeArgs, inExpressionContext);
			e = new ExprDotName(tok, e, tok.val, typeArgs); 
		}
		ty = new UserDefinedType(e.tok, e);
		ty.RangeToken = new RangeToken(startToken, t);
		
	}

	void NameSegmentForTypeName(out Expression e, bool inExpressionContext) {
		IToken id;  List<Type> typeArgs; 
		Ident(out id);
		OptGenericInstantiation(out typeArgs, inExpressionContext);
		e = new NameSegment(id, id.val, typeArgs);
		e.RangeToken = new RangeToken(id, t);
		
	}

	void GenericInstantiation(List<Type> gt) {
		Contract.Requires(cce.NonNullElements(gt)); Type/*!*/ ty; 
		Expect(90);
		if (la.kind == 91) {
			Get();
			SemErr(ErrorId.p_no_empty_type_parameter_list, t, "empty type parameter lists are not permitted"); 
		} else if (StartOf(5)) {
			Type(out ty);
			gt.Add(ty); 
			while (la.kind == 25) {
				Get();
				Type(out ty);
				gt.Add(ty); 
			}
			Expect(91);
		} else SynErr(204);
	}

	void PredicateResult(string name, out Formal result) {
		Type/*!*/ returnType = new BoolType();
		result = null;
		Attributes attributes = null;
		
		Expect(24);
		if (IsParenIdentsColon()) {
			Expect(88);
			while (la.kind == 83) {
				Attribute(ref attributes);
			}
			GIdentType(false, false, false, false, out var range, out var nameId, out var ty, out var resultIsGhost, out var isOld, out var isNameOnly, out var isOlder);
			if (ty is not BoolType) {
			 SemErr(ErrorId.p_predicate_return_type_must_be_bool, new RangeToken(ty.StartToken, t), $"{name} return type should be bool, got {ty}");
			}
			result = new Formal(nameId.Tok, nameId.Value, ty, false, false, null, attributes, false)
			 { RangeToken = range, IsTypeExplicit = ty != null };
			
			Expect(89);
		} else if (StartOf(5)) {
			Type(out returnType);
			SemErr(ErrorId.p_no_return_type_for_predicate, new RangeToken(returnType.StartToken, t), $"{name}s do not have an explicitly declared return type; it is always bool. Unless you want to name the result: ': (result: bool)'"); 
		} else SynErr(205);
	}

	void FunctionSpec(List<AttributedExpression> reqs, List<FrameExpression> reads, List<AttributedExpression> ens, List<Expression> decreases, ref Attributes decAttrs, ref Attributes readsAttrs) {
		Contract.Requires(cce.NonNullElements(reqs));
		Contract.Requires(cce.NonNullElements(reads));
		Contract.Requires(decreases == null || cce.NonNullElements(decreases));
		
		while (!(StartOf(24))) {SynErr(206); Get();}
		while (StartOf(25)) {
			if (la.kind == 73) {
				RequiresClause(reqs, true);
			} else if (la.kind == 72) {
				ReadsClause(reads, ref readsAttrs, false, false, true);
			} else if (la.kind == 74) {
				EnsuresClause(ens, false);
			} else {
				var decreasesToken = la;
				var decreasesForbidden = decreases == null;
				if (decreases == null) {
				 decreases = new List<Expression/*!*/>();
				}
				
				DecreasesClause(decreases, ref decAttrs, false, false);
				if (decreasesForbidden) {
				var erange = new RangeToken(decreasesToken, t);
				SemErr(ErrorId.p_no_decreases_for_extreme_predicates, erange, "'decreases' clauses are meaningless for least and greatest predicates, so they are not allowed");
				}
			}
		}
	}

	void FunctionBody(out Expression/*!*/ e, out IToken bodyStart, out IToken bodyEnd, out IToken/*?*/ byMethodTok, out BlockStmt/*?*/ byMethodBody) {
		Contract.Ensures(Contract.ValueAtReturn(out e) != null); e = dummyExpr;
		byMethodTok = null; byMethodBody = null;
		
		Expect(84);
		bodyStart = t;
		var errorCount_curr = errors.ErrorCount; 
		
		Expression(out e, true, true);
		if (errorCount_curr != errors.ErrorCount){
			Console.WriteLine("error found in parsing expression");
			errors.ErrorCount = errorCount_curr;

					
			int nesting = 1; 
		
			if (la.kind != 0){
				Console.WriteLine("EOF found unexpectedly");
			}
			while (nesting != 0 && la.kind != 0 && la.val != "}"){
				Console.WriteLine("TOKEN: {0} {1}", t.val, la.val);
				Get(); // If there's an error ( basically it's a BlockStmt)
				if (la.kind == 84){
					Console.WriteLine("Increment nesting");
					nesting = nesting + 1; 
				}
				if (la.kind == 85){
					nesting = nesting - 1;
					Console.WriteLine("Decrement nesting"); 
				}
			}
			e = new HoleExpr(t, "The function doesn't have an expression. Most likely it's a method body intead of function body.");
			Console.WriteLine("Expect 85 @ Line 2842");
		}
		else if (e is HoleExpr){
			Console.WriteLine ("hole found");

		}
		Expect(85);
		bodyEnd = t; 
		if (la.kind == 42) {
			Get();
			byMethodTok = t; 
			Expect(68);
			BlockStmt(out byMethodBody, out _, out _);
		}
	}

	void PossiblyWildExpression(out Expression e, bool allowLambda, bool allowWild) {
		Contract.Ensures(Contract.ValueAtReturn(out e)!=null);
		e = dummyExpr; 
		if (la.kind == 95) {
			Get();
			e = new WildcardExpr(t);
			if (!allowWild) {
			 SemErr(ErrorId.p_no_wild_expression, e.tok, "A '*' expression is not allowed here");
			}
			
		} else if (StartOf(4)) {
			Expression(out e, false, allowLambda);
		} else SynErr(207);
	}

	void FrameField(out IToken id) {
		Expect(31);
		IdentOrDigits(out id);
	}

	void IdentOrDigits(out IToken id) {
		id = Token.NoToken; 
		if (StartOf(9)) {
			Ident(out id);
		} else if (la.kind == 2) {
			Get();
			id = t; 
		} else SynErr(208);
	}

	void Stmt(List<Statement/*!*/>/*!*/ ss) {
		Statement/*!*/ s;
		
		OneStmt(out s);
		ss.Add(s); 
	}

	void OneStmt(out Statement/*!*/ s) {
		Contract.Ensures(Contract.ValueAtReturn(out s) != null);
		s = dummyStmt;  /* to please the compiler */
		BlockStmt bs;
		IToken bodyStart, bodyEnd;
		
		while (!(StartOf(26))) {SynErr(209); Get();}
		switch (la.kind) {
		case 84: {
			BlockStmt(out bs, out bodyStart, out bodyEnd);
			s = bs; 
			break;
		}
		case 1: case 2: case 3: case 4: case 22: case 23: case 26: case 45: case 49: case 50: case 51: case 81: case 88: case 121: case 142: case 143: case 144: case 145: case 146: case 147: case 148: case 149: {
			UpdateStmt(out s);
			break;
		}
		case 63: case 75: {
			VarDeclStatement(out s);
			break;
		}
		case 120: {
			ReturnStmt(out s);
			break;
		}
		case 122: {
			IfStmt(out s);
			break;
		}
		case 123: {
			WhileStmt(out s);
			break;
		}
		case 124: {
			ForLoopStmt(out s);
			break;
		}
		case 35: {
			AssertStmt(out s);
			break;
		}
		case 34: {
			AssumeStmt(out s);
			break;
		}
		case 118: case 119: {
			BreakStmt(out s);
			break;
		}
		case 36: {
			CalcStmt(out s);
			break;
		}
		case 100: {
			ExpectStmt(out s);
			break;
		}
		case 127: {
			ForallStmt(out s);
			break;
		}
		case 117: {
			LabeledStmt(out s);
			break;
		}
		case 125: {
			MatchStmt(out s);
			break;
		}
		case 128: {
			ModifyStmt(out s);
			break;
		}
		case 126: {
			PrintStmt(out s);
			break;
		}
		case 99: {
			RevealStmt(out s);
			break;
		}
		case 98: {
			SkeletonStmt(out s);
			break;
		}
		case 116: {
			YieldStmt(out s);
			break;
		}
		default: SynErr(210); break;
		}
	}

	void UpdateStmt(out Statement/*!*/ s) {
		List<Expression> lhss = new List<Expression>();
		List<AssignmentRhs> rhss = new List<AssignmentRhs>();
		Expression e;
		AssignmentRhs r;
		IToken x = Token.NoToken;
		IToken endTok = Token.NoToken;
		IToken startToken = Token.NoToken;
		Attributes attrs = null;
		Attributes tokenAttrs = null;
		AttributedToken suchThatAssume = null;
		Expression suchThat = null;
		AttributedToken keywordToken = null;
		Expression exceptionExpr = null;
		ExprRhs exceptionRhs = null;
		IToken endToken = Token.NoToken;
		
		if (StartOf(27)) {
			Lhs(out e);
			x = e.tok; startToken = e.StartToken; endToken = t; 
			if (StartOf(28)) {
				lhss.Add(e); 
				while (la.kind == 25) {
					Get();
					Lhs(out e);
					lhss.Add(e); 
				}
				if (la.kind == 28) {
					Get();
					x = t; 
					Rhs(out r);
					rhss.Add(r); 
					while (la.kind == 25) {
						Get();
						Rhs(out r);
						rhss.Add(r); 
					}
				} else if (la.kind == 29) {
					Get();
					x = t; 
					if (la.kind == _assume) {
						Expect(34);
						var tok = t; 
						while (la.kind == 83) {
							Attribute(ref tokenAttrs);
						}
						suchThatAssume = new AttributedToken(tok, tokenAttrs); 
					}
					Expression(out suchThat, false, true);
				} else if (la.kind == 121) {
					Get();
					x = t; 
					if (IsAssumeTypeKeyword(la)) {
						if (la.kind == 100) {
							Get();
						} else if (la.kind == 35) {
							Get();
						} else if (la.kind == 34) {
							Get();
						} else SynErr(211);
						var tok = t; 
						while (la.kind == 83) {
							Attribute(ref tokenAttrs);
						}
						keywordToken = new AttributedToken(tok, tokenAttrs); 
					}
					Expression(out exceptionExpr, false, false);
					while (la.kind == 83) {
						Attribute(ref attrs);
					}
					exceptionRhs = new ExprRhs(exceptionExpr, attrs); 
					while (la.kind == 25) {
						Get();
						Rhs(out r);
						rhss.Add(r); 
					}
				} else SynErr(212);
				Expect(32);
				endTok = t; 
			} else if (la.kind == 24) {
				Get();
				SemErr(ErrorId.p_invalid_colon, new RangeToken(startToken, t), "invalid statement beginning here (is a 'label' keyword missing? or a 'const' or 'var' keyword?)"); 
			} else if (la.kind == 32 || la.kind == 83) {
				while (la.kind == 83) {
					Attribute(ref attrs);
				}
				endToken = t; 
				Expect(32);
				endTok = t; rhss.Add(new ExprRhs(e, attrs) { RangeToken = new RangeToken(e.StartToken, endToken) }); 
			} else if (StartOf(29)) {
				while (la.kind == 83) {
					Attribute(ref attrs);
				}
				endToken = t; 
				endTok = t; rhss.Add(new ExprRhs(e, attrs) { RangeToken = new RangeToken(e.StartToken, endToken) });
				SemErr(ErrorId.p_missing_semicolon, new RangeToken(startToken, t), "missing semicolon at end of statement");
				
			} else SynErr(213);
		} else if (la.kind == 121) {
			Get();
			x = t; startToken = t; 
			if (IsAssumeTypeKeyword(la)) {
				if (la.kind == 100) {
					Get();
				} else if (la.kind == 35) {
					Get();
				} else if (la.kind == 34) {
					Get();
				} else SynErr(214);
				var tok = t; 
				while (la.kind == 83) {
					Attribute(ref tokenAttrs);
				}
				keywordToken = new AttributedToken(tok, tokenAttrs); 
			}
			Expression(out exceptionExpr, false, false);
			while (la.kind == 83) {
				Attribute(ref attrs);
			}
			exceptionRhs = new ExprRhs(exceptionExpr, attrs); 
			while (la.kind == 25) {
				Get();
				Rhs(out r);
				rhss.Add(r); 
			}
			Expect(32);
			endTok = t; 
		} else SynErr(215);
		var rangeToken = new RangeToken(startToken, t);
		if (suchThat != null) {
		 s = new AssignSuchThatStmt(rangeToken, lhss, suchThat, suchThatAssume, null);
		} else if (exceptionRhs != null) {
		 s = new AssignOrReturnStmt(rangeToken, lhss, exceptionRhs, keywordToken, rhss);
		} else {
		 if (lhss.Count == 0 && rhss.Count == 0) {
		   s = new BlockStmt(rangeToken, new List<Statement>()); // error, give empty statement
		 } else {
		   s = new UpdateStmt(rangeToken, lhss, rhss);
		 }
		}
		
	}

	void VarDeclStatement(out Statement/*!*/ s) {
		IToken x = null, assignTok = null;  bool isGhost = false;
		LocalVariable d;
		AssignmentRhs r;
		List<LocalVariable> lhss = new List<LocalVariable>();
		List<AssignmentRhs> rhss = new List<AssignmentRhs>();
		AttributedToken suchThatAssume = null;
		Expression suchThat = null;
		AttributedToken keywordToken = null;
		Expression exceptionExpr = null;
		ExprRhs exceptionRhs = null;
		Attributes attrs = null;
		Attributes tokenAttrs = null;
		IToken endTok;
		IToken startToken = null;
		s = dummyStmt;
		
		if (la.kind == 75) {
			Get();
			isGhost = true;  x = t; startToken = t; 
		}
		Expect(63);
		if (!isGhost) { x = t; startToken = t; } 
		if (!IsPatternDecl()) {
			while (la.kind == 83) {
				Attribute(ref attrs);
			}
			LocalIdentTypeOptional(out d, isGhost);
			lhss.Add(d); d.Attributes = attrs; attrs = null; 
			while (la.kind == 25) {
				Get();
				while (la.kind == 83) {
					Attribute(ref attrs);
				}
				LocalIdentTypeOptional(out d, isGhost);
				lhss.Add(d); d.Attributes = attrs; attrs = null; 
			}
			if (StartOf(30)) {
				if (la.kind == 28 || la.kind == 92) {
					if (la.kind == 28) {
						Get();
					} else {
						Get();
						SemErr(ErrorId.p_no_equal_for_initializing, t, "a local variable should be initialized using ':=', ':-', or ':|', not '='"); 
					}
					assignTok = t; 
					Rhs(out r);
					rhss.Add(r); 
					while (la.kind == 25) {
						Get();
						Rhs(out r);
						rhss.Add(r); 
					}
				} else if (la.kind == 29 || la.kind == 83) {
					while (la.kind == 83) {
						Attribute(ref attrs);
					}
					Expect(29);
					assignTok = t; 
					if (la.kind == _assume) {
						Expect(34);
						var tok = t; 
						while (la.kind == 83) {
							Attribute(ref tokenAttrs);
						}
						suchThatAssume = new AttributedToken(tok, tokenAttrs); 
					}
					Expression(out suchThat, false, true);
				} else {
					Get();
					assignTok = t; 
					if (IsAssumeTypeKeyword(la)) {
						if (la.kind == 100) {
							Get();
						} else if (la.kind == 35) {
							Get();
						} else if (la.kind == 34) {
							Get();
						} else SynErr(216);
						var tok = t; 
						while (la.kind == 83) {
							Attribute(ref tokenAttrs);
						}
						keywordToken = new AttributedToken(tok, tokenAttrs); 
					}
					Expression(out exceptionExpr, false, false);
					while (la.kind == 83) {
						Attribute(ref attrs);
					}
					exceptionRhs = new ExprRhs(exceptionExpr, attrs); 
					while (la.kind == 25) {
						Get();
						Rhs(out r);
						rhss.Add(r); 
					}
				}
			}
			while (!(la.kind == 0 || la.kind == 32)) {SynErr(217); Get();}
			Expect(32);
			endTok = t; 
			ConcreteUpdateStatement update;
			var lhsExprs = new List<Expression>();
			if (isGhost || (rhss.Count == 0 && exceptionRhs == null && suchThat == null)) { // explicitly ghost or no init
			 foreach (var lhs in lhss) {
			   lhsExprs.Add(new IdentifierExpr(lhs.Tok, lhs.Name) { RangeToken = new RangeToken(lhs.Tok, lhs.Tok) } );
			 }
			} else { // not explicitly ghost, but with init - so auto-ghost
			 foreach (var lhs in lhss) {
			   lhsExprs.Add(new AutoGhostIdentifierExpr(lhs.Tok, lhs.Name) { RangeToken = new RangeToken(lhs.Tok, lhs.Tok) } );
			 }
			}
			var rangeToken = new RangeToken(startToken, t);
			var updateRangeToken = new RangeToken(assignTok, t);
			if (suchThat != null) {
			 update = new AssignSuchThatStmt(updateRangeToken, lhsExprs, suchThat, suchThatAssume, attrs);
			} else if (exceptionRhs != null) {
			 update = new AssignOrReturnStmt(updateRangeToken, lhsExprs, exceptionRhs, keywordToken, rhss);
			} else if (rhss.Count == 0) {
			 update = null;
			} else {
			 update = new UpdateStmt(updateRangeToken, lhsExprs, rhss);
			}
			s = new VarDeclStmt(rangeToken, lhss, update);
			
		} else if (StartOf(31)) {
			CasePattern<LocalVariable> pat;
			Expression e = dummyExpr;
			IToken id = t;
			
			CasePatternLocal(out pat, isGhost);
			if (la.kind == 28) {
				Get();
			} else if (la.kind == 29 || la.kind == 83) {
				while (la.kind == 83) {
					Attribute(ref attrs);
				}
				Expect(29);
				SemErr(ErrorId.p_no_patterns_and_such_that, pat.tok, "LHS of assign-such-that expression must be variables, not general patterns"); 
			} else SynErr(218);
			Expression(out e, false, true);
			Expect(32);
			s = new VarDeclPattern(e.RangeToken, pat, e, isGhost);
			s.RangeToken = new RangeToken(pat.StartToken, t); 
		} else SynErr(219);
	}

	void ReturnStmt(out Statement/*!*/ s) {
		Expect(120);
		IToken returnTok = t;
		List<AssignmentRhs> rhss = null;
		AssignmentRhs r;
		
		if (StartOf(32)) {
			Rhs(out r);
			rhss = new List<AssignmentRhs>();
			rhss.Add(r);
			
			while (la.kind == 25) {
				Get();
				Rhs(out r);
				rhss.Add(r); 
			}
		}
		Expect(32);
		s = new ReturnStmt(new RangeToken(returnTok, t), rhss);
		
	}

	void IfStmt(out Statement/*!*/ ifStmt) {
		Contract.Ensures(Contract.ValueAtReturn(out ifStmt) != null); IToken/*!*/ x;
		Expression guard = null;  IToken guardEllipsis = null;  bool isBindingGuard = false;
		BlockStmt/*!*/ thn;
		BlockStmt/*!*/ bs;
		Statement/*!*/ s;
		Statement els = null;
		Attributes attrs = null;
		Attributes elsattrs = null;
		IToken bodyStart, bodyEnd;
		IToken endTok;
		IToken startToken;
		List<GuardedAlternative> alternatives;
		ifStmt = dummyIfStmt;  // to please the compiler
		bool usesOptionalBraces;
		
		Expect(122);
		x = t; startToken = t; 
		while (la.kind == 83) {
			Attribute(ref attrs);
		}
		if (IsAlternative()) {
			AlternativeBlock(true, out alternatives, out usesOptionalBraces, out endTok);
			ifStmt = new AlternativeStmt(new RangeToken(startToken, t), alternatives, usesOptionalBraces, attrs);
			
		} else if (StartOf(33)) {
			if (IsBindingGuard()) {
				BindingGuard(out guard, true);
				isBindingGuard = true; 
			} else if (StartOf(32)) {
				Guard(out guard);
			} else {
				Get();
				guardEllipsis = t;
				errors.Deprecated(ErrorId.p_deprecated_statement_refinement, t, "the ... refinement feature in statements is deprecated");
				
			}
			BlockStmt(out thn, out bodyStart, out bodyEnd);
			if (la.kind == 39) {
				Get();
				if (la.kind == 122) {
					IfStmt(out s);
					els = s; 
				} else if (la.kind == 83 || la.kind == 84) {
					while (la.kind == 83) {
						Attribute(ref elsattrs);
					}
					BlockStmt(out bs, out bodyStart, out bodyEnd);
					els = bs; 
				} else SynErr(220);
			}
			if (els != null && !(els is IfStmt)) {
			els.Attributes = elsattrs;
			}
			var rangeToken = new RangeToken(startToken, t);
			if (guardEllipsis != null) {
			 ifStmt = new IfStmt(rangeToken, isBindingGuard, guard, thn, els);
			 ifStmt = new SkeletonStatement(ifStmt, guardEllipsis, null);
			} else {
			 ifStmt = new IfStmt(rangeToken, isBindingGuard, guard, thn, els, attrs);
			}
			
		} else SynErr(221);
	}

	void WhileStmt(out Statement stmt) {
		Contract.Ensures(Contract.ValueAtReturn(out stmt) != null); IToken x;
		Expression guard = null;  IToken guardEllipsis = null;
		Attributes attrs = null;
		List<AttributedExpression> invariants = new List<AttributedExpression>();
		List<Expression> decreases = new List<Expression>();
		IToken startToken = null;
		Attributes decAttrs = null;
		Attributes modAttrs = null;
		List<FrameExpression> mod = null;
		BlockStmt body = null;  IToken bodyEllipsis = null;
		IToken bodyStart = null, bodyEnd = null;
		IToken endTok;
		List<GuardedAlternative> alternatives;
		stmt = dummyStmt;  // to please the compiler
		bool isDirtyLoop = true;
		bool usesOptionalBraces;
		
		Expect(123);
		x = t; startToken = t; 
		while (la.kind == 83) {
			Attribute(ref attrs);
		}
		if (IsLoopSpec() || IsAlternative()) {
			LoopSpec(invariants, decreases, ref mod, ref decAttrs, ref modAttrs);
			AlternativeBlock(false, out alternatives, out usesOptionalBraces, out endTok);
			stmt = new AlternativeLoopStmt(new RangeToken(startToken, t), invariants, new Specification<Expression>(decreases, decAttrs), new Specification<FrameExpression>(mod, modAttrs), alternatives, usesOptionalBraces, attrs);
			
		} else if (StartOf(33)) {
			if (StartOf(32)) {
				Guard(out guard);
				Contract.Assume(guard == null || cce.Owner.None(guard)); 
			} else {
				Get();
				guardEllipsis = t; 
				errors.Deprecated(ErrorId.p_deprecated_statement_refinement, t, "the ... refinement feature in statements is deprecated");
				
			}
			LoopSpec(invariants, decreases, ref mod, ref decAttrs, ref modAttrs);
			if (la.kind == _lbrace) {
				BlockStmt(out body, out bodyStart, out bodyEnd);
				isDirtyLoop = false; 
			} else if (la.kind == _ellipsis) {
				Expect(98);
				bodyEllipsis = t; isDirtyLoop = false;
				errors.Deprecated(ErrorId.p_deprecated_statement_refinement, t, "the ... refinement feature in statements is deprecated");
				
			} else if (StartOf(34)) {
			} else SynErr(222);
			var rangeToken = new RangeToken(startToken, t);
			if (guardEllipsis != null || bodyEllipsis != null) {
			 if (mod != null) {
			   SemErr(ErrorId.p_no_modifies_on_refining_loops, mod[0].E.tok, "'modifies' clauses are not allowed on refining loops");
			 }
			 if (body == null && !isDirtyLoop) {
			   body = new BlockStmt(rangeToken, new List<Statement>());
			 }
			 stmt = new WhileStmt(rangeToken, guard, invariants, new Specification<Expression>(decreases, decAttrs), new Specification<FrameExpression>(null, null), body, attrs);
			 stmt = new SkeletonStatement(stmt, guardEllipsis, bodyEllipsis);
			} else {
			 // The following statement protects against crashes in case of parsing errors
			 if (body == null && !isDirtyLoop) {
			   body = new BlockStmt(rangeToken, new List<Statement>());
			 }
			 stmt = new WhileStmt(rangeToken, guard, invariants, new Specification<Expression>(decreases, decAttrs), new Specification<FrameExpression>(mod, modAttrs), body, attrs);
			}
			
		} else SynErr(223);
	}

	void ForLoopStmt(out Statement stmt) {
		Contract.Ensures(Contract.ValueAtReturn(out stmt) != null);
		IToken x;
		BoundVar loopIndex;
		Expression start;
		Expression end = null;
		bool goingUp = true;
		
		Attributes attrs = null;
		
		List<AttributedExpression> invariants = new List<AttributedExpression>();
		List<Expression> decreases = new List<Expression>();
		IToken startToken = null;
		Attributes decAttrs = null;
		Attributes modAttrs = null;
		List<FrameExpression> mod = null;
		
		BlockStmt body = null;
		IToken bodyStart = null, bodyEnd = null;
		stmt = dummyStmt;  // to please the compiler
		bool isDirtyLoop = true;
		
		Expect(124);
		x = t; startToken = t; 
		while (la.kind == 83) {
			Attribute(ref attrs);
		}
		IdentTypeOptional(out loopIndex);
		Expect(28);
		Expression(out start, false, false);
		ForLoopDirection(out goingUp);
		if (StartOf(4)) {
			Expression(out end, false, false);
		} else if (la.kind == 95) {
			Get();
		} else SynErr(224);
		LoopSpec(invariants, decreases, ref mod, ref decAttrs, ref modAttrs);
		if (la.kind == _lbrace) {
			BlockStmt(out body, out bodyStart, out bodyEnd);
			isDirtyLoop = false; 
		} else if (StartOf(34)) {
		} else SynErr(225);
		var rangeToken = new RangeToken(startToken, t);
		// The following statement protects against crashes in case of parsing errors
		if (body == null && !isDirtyLoop) {
		 body = new BlockStmt(rangeToken, new List<Statement>());
		}
		stmt = new ForLoopStmt(rangeToken, loopIndex, start, end, goingUp,
		 invariants, new Specification<Expression>(decreases, decAttrs), new Specification<FrameExpression>(mod, modAttrs), body, attrs);
		
	}

	void AssertStmt(out Statement/*!*/ s) {
		Contract.Ensures(Contract.ValueAtReturn(out s) != null); IToken/*!*/ x;
		Expression e = dummyExpr; Attributes attrs = null;
		IToken dotdotdot = null;
		BlockStmt proof = null;
		IToken startToken = null;
		IToken proofStart, proofEnd;
		IToken lbl = null;
		
		Expect(35);
		x = t; startToken = t; 
		while (la.kind == 83) {
			Attribute(ref attrs);
		}
		if (StartOf(4)) {
			if (IsLabel(true)) {
				LabelName(out lbl);
				Expect(24);
			}
			Expression(out e, false, true);
			if (la.kind == 42) {
				Get();
				BlockStmt(out proof, out proofStart, out proofEnd);
			} else if (la.kind == 32) {
				Get();
			} else if (StartOf(35)) {
				SemErr(ErrorId.p_assert_needs_by_or_semicolon, t, "expected either 'by' or a semicolon following the assert expression");
				
			} else SynErr(226);
		} else if (la.kind == 98) {
			Get();
			dotdotdot = t; 
			errors.Deprecated(ErrorId.p_deprecated_statement_refinement, t, "the ... refinement feature in statements is deprecated");
			
			Expect(32);
		} else SynErr(227);
		if (dotdotdot != null) {
		 s = new AssertStmt(new RangeToken(startToken, t), new LiteralExpr(x, true), null, null, attrs);
		 s = new SkeletonStatement(s, dotdotdot, null);
		} else {
		 s = new AssertStmt(new RangeToken(startToken, t), e, proof, lbl == null ? null : new AssertLabel(lbl, lbl.val), attrs);
		}
		
	}

	void AssumeStmt(out Statement/*!*/ s) {
		Contract.Ensures(Contract.ValueAtReturn(out s) != null); IToken/*!*/ x;
		Expression e = dummyExpr; Attributes attrs = null;
		IToken dotdotdot = null;
		IToken startToken = null;
		
		Expect(34);
		x = t; startToken = t; 
		while (la.kind == 83) {
			Attribute(ref attrs);
		}
		if (StartOf(4)) {
			Expression(out e, false, true);
		} else if (la.kind == 98) {
			Get();
			dotdotdot = t; 
			errors.Deprecated(ErrorId.p_deprecated_statement_refinement, t, "the ... refinement feature in statements is deprecated");
			
		} else SynErr(228);
		Expect(32);
		if (dotdotdot != null) {
		 s = new AssumeStmt(new RangeToken(startToken, t), new LiteralExpr(x, true), attrs);
		 s = new SkeletonStatement(s, dotdotdot, null);
		} else {
		 s = new AssumeStmt(new RangeToken(startToken, t), e, attrs);
		}
		
	}

	void BreakStmt(out Statement/*!*/ s) {
		var isContinue = false;
		IToken start = Token.NoToken;
		IToken label = null;
		int breakAndContinueCount = 1;
		
		if (la.kind == 118) {
			Get();
			start = t; isContinue = true; 
			if (StartOf(10)) {
				LabelName(out label);
			}
		} else if (la.kind == 119) {
			Get();
			start = t; 
			if (StartOf(10)) {
				LabelName(out label);
			} else if (la.kind == 32 || la.kind == 118 || la.kind == 119) {
				while (la.kind == 119) {
					Get();
					breakAndContinueCount++; 
				}
				if (la.kind == 118) {
					Get();
					breakAndContinueCount++; isContinue = true; 
				}
			} else SynErr(229);
		} else SynErr(230);
		while (!(la.kind == 0 || la.kind == 32)) {SynErr(231); Get();}
		Expect(32);
		Contract.Assert(label == null || breakAndContinueCount == 1);
		s = label != null ?
		 new BreakStmt(new RangeToken(start, t), label, isContinue) :
		 new BreakStmt(new RangeToken(start, t), breakAndContinueCount, isContinue);
		
	}

	void CalcStmt(out Statement s) {
		Contract.Ensures(Contract.ValueAtReturn(out s) != null);
		IToken x;
		Attributes attrs = null;
		CalcStmt.CalcOp op, userSuppliedOp = null, resOp = Microsoft.Dafny.CalcStmt.DefaultOp;
		var lines = new List<Expression>();
		var hints = new List<BlockStmt>();
		CalcStmt.CalcOp stepOp;
		var stepOps = new List<CalcStmt.CalcOp>();
		IToken startToken = null;
		Expression e;
		IToken opTok;
		IToken danglingOperator = null;
		
		Expect(36);
		x = t; startToken = t; 
		while (la.kind == 83) {
			Attribute(ref attrs);
		}
		if (StartOf(36)) {
			CalcOp(out opTok, out userSuppliedOp);
			if (userSuppliedOp.ResultOp(userSuppliedOp) == null) { // guard against non-transitive calcOp (like !=)
			 SemErr(ErrorId.p_calc_operator_must_be_transitive, opTok, "the main operator of a calculation must be transitive");
			} else {
			 resOp = userSuppliedOp;
			}
			
		}
		Expect(84);
		while (StartOf(4)) {
			Expression(out e, false, true);
			lines.Add(e); stepOp = null; danglingOperator = null; 
			Expect(32);
			if (StartOf(36)) {
				CalcOp(out opTok, out op);
				var maybeOp = resOp.ResultOp(op);
				if (maybeOp == null) {
				 SemErr(ErrorId.p_invalid_calc_op_combination, opTok, "this operator cannot continue this calculation");
				} else {
				 stepOp = op;
				 resOp = maybeOp;
				 danglingOperator = opTok;
				}
				
			}
			stepOps.Add(stepOp); 
			var subhints = new List<Statement>();
			IToken hintStart = la;  IToken hintEnd = hintStart.Prev;
			IToken t0, t1;
			BlockStmt subBlock; Statement subCalc;
			
			while (la.kind == _lbrace || la.kind == _calc) {
				if (la.kind == 84) {
					BlockStmt(out subBlock, out t0, out t1);
					hintEnd = subBlock.EndToken; subhints.Add(subBlock); 
				} else if (la.kind == 36) {
					CalcStmt(out subCalc);
					hintEnd = subCalc.EndToken; subhints.Add(subCalc); 
				} else SynErr(232);
			}
			var h = new BlockStmt(new RangeToken(hintStart, hintEnd), subhints); // if the hint is empty, hintStart is the first token of the next line, but it doesn't matter because the block statement is just used as a container
			hints.Add(h);
			if (h.Body.Count != 0) { danglingOperator = null; }
			
		}
		Expect(85);
		if (danglingOperator != null) {
		 SemErr(ErrorId.p_calc_dangling_operator, danglingOperator, "a calculation cannot end with an operator");
		}
		if (lines.Count > 0) {
		 // Repeat the last line to create a dummy line for the dangling hint
		 lines.Add(lines[lines.Count - 1]);
		}
		s = new CalcStmt(new RangeToken(startToken, t), userSuppliedOp, lines, hints, stepOps, attrs);
		
	}

	void ExpectStmt(out Statement/*!*/ s) {
		Contract.Ensures(Contract.ValueAtReturn(out s) != null); IToken/*!*/ x;
		Expression e = dummyExpr; Expression m = null; Attributes attrs = null;
		IToken dotdotdot = null;
		IToken startToken = null;
		
		Expect(100);
		x = t; startToken = t; 
		while (la.kind == 83) {
			Attribute(ref attrs);
		}
		if (StartOf(4)) {
			Expression(out e, false, true);
		} else if (la.kind == 98) {
			Get();
			dotdotdot = t; 
			errors.Deprecated(ErrorId.p_deprecated_statement_refinement, t, "the ... refinement feature in statements is deprecated");
			
		} else SynErr(233);
		if (la.kind == 25) {
			Get();
			Expression(out m, false, true);
		}
		Expect(32);
		if (dotdotdot != null) {
		 s = new ExpectStmt(new RangeToken(startToken, t), new LiteralExpr(x, true), m, attrs);
		 s = new SkeletonStatement(s, dotdotdot, null);
		} else {
		 s = new ExpectStmt(new RangeToken(startToken, t), e, m, attrs);
		}
		
	}

	void ForallStmt(out Statement/*!*/ s) {
		Contract.Ensures(Contract.ValueAtReturn(out s) != null);
		IToken/*!*/ x = Token.NoToken;
		List<BoundVar> bvars = null;
		Attributes qattrs = null;
		Expression range = null;
		var ens = new List<AttributedExpression/*!*/>();
		IToken startToken = null;
		BlockStmt block = null;
		IToken bodyStart, bodyEnd;
		IToken tok = Token.NoToken;
		
		Expect(127);
		x = t; tok = x; startToken = t; 
		if (la.kind == _openparen) {
			Expect(88);
			if (StartOf(9)) {
				QuantifierDomain(out bvars, out qattrs, out range, true, true, true);
			}
			Expect(89);
		} else if (StartOf(37)) {
			if (IsIdentifier(la.kind)) {
				QuantifierDomain(out bvars, out qattrs, out range, true, true, true);
			}
		} else SynErr(234);
		if (bvars == null) errors.Deprecated(ErrorId.p_deprecated_forall_with_no_bound_variables, startToken, "a forall statement with no bound variables is deprecated; use an 'assert by' statement instead");
		if (bvars == null) { bvars = new List<BoundVar>(); }
		if (range == null) { range = new LiteralExpr(x, true); }
		
		while (la.kind == 74) {
			EnsuresClause(ens, true);
		}
		if (la.kind == _lbrace) {
			BlockStmt(out block, out bodyStart, out bodyEnd);
		}
		if (theOptions.DisallowSoundnessCheating && block == null && 0 < ens.Count) {
		  SemErr(ErrorId.p_forall_with_ensures_must_have_body, t, "a forall statement with an ensures clause must have a body");
		}
		
		s = new ForallStmt(new RangeToken(startToken, t), bvars, qattrs, range, ens, block);
		
	}

	void LabeledStmt(out Statement s) {
		IToken colonToken;
		IToken labelToken;
		
		Expect(117);
		IToken id; labelToken = t; 
		LabelName(out id);
		Expect(24);
		colonToken = t; 
		OneStmt(out s);
		s.Labels = new LList<Label>(new Label(id, id.val), s.Labels);
		s.PostLabelToken = s.StartToken;
		s.RangeToken = new RangeToken(labelToken, t);
		
	}

	void MatchStmt(out Statement/*!*/ s) {
		Contract.Ensures(Contract.ValueAtReturn(out s) != null);
		IToken x; Expression/*!*/ e; NestedMatchCaseStmt/*!*/ c;
		List<NestedMatchCaseStmt/*!*/> cases = new List<NestedMatchCaseStmt/*!*/>();
		bool usesOptionalBraces = false;
		IToken startToken = null;
		Attributes attrs = null;
		
		Expect(125);
		x = t; startToken = t; 
		while (la.kind == 83) {
			Attribute(ref attrs);
		}
		Expression(out e, true, true);
		if (la.kind == _lbrace) {
			Expect(84);
			usesOptionalBraces = true; 
			while (la.kind == 37) {
				CaseStmt(out c);
				cases.Add(c); 
			}
			Expect(85);
		} else if (StartOf(34)) {
			while (la.kind == _case) {
				CaseStmt(out c);
				cases.Add(c); 
			}
		} else SynErr(235);
		s = new NestedMatchStmt(new RangeToken(startToken, t), e, cases, usesOptionalBraces, attrs);
		
	}

	void ModifyStmt(out Statement s) {
		IToken tok;  IToken endTok = Token.NoToken;
		Attributes attrs = null;
		FrameExpression fe;  var mod = new List<FrameExpression>();
		BlockStmt body = null;  IToken bodyStart;
		IToken ellipsisToken = null;
		IToken startToken = null;
		
		Expect(128);
		tok = t; startToken = t; 
		while (la.kind == 83) {
			Attribute(ref attrs);
		}
		if (StartOf(22)) {
			FrameExpression(out fe, false, true);
			mod.Add(fe); 
			while (la.kind == 25) {
				Get();
				FrameExpression(out fe, false, true);
				mod.Add(fe); 
			}
		} else if (la.kind == 98) {
			Get();
			ellipsisToken = t; 
			errors.Deprecated(ErrorId.p_deprecated_statement_refinement, t, "the ... refinement feature in statements is deprecated");
			
		} else SynErr(236);
		if (la.kind == 84) {
			BlockStmt(out body, out bodyStart, out endTok);
			errors.Deprecated(ErrorId.p_deprecated_modify_statement_with_block, bodyStart, "the modify statement with a block statement is deprecated");
			
		} else if (la.kind == 32) {
			while (!(la.kind == 0 || la.kind == 32)) {SynErr(237); Get();}
			Get();
			endTok = t; 
		} else SynErr(238);
		s = new ModifyStmt(new RangeToken(startToken, t), mod, attrs, body);
		if (ellipsisToken != null) {
		 s = new SkeletonStatement(s, ellipsisToken, null);
		}
		
	}

	void PrintStmt(out Statement s) {
		Contract.Ensures(Contract.ValueAtReturn(out s) != null);
		IToken x;  Expression e;
		var args = new List<Expression>();
		IToken startToken = null;
		
		Expect(126);
		x = t; startToken = t; 
		Expression(out e, false, true);
		args.Add(e); 
		while (la.kind == 25) {
			Get();
			Expression(out e, false, true);
			args.Add(e); 
		}
		Expect(32);
		s = new PrintStmt(new RangeToken(startToken, t), args);
		
	}

	void RevealStmt(out Statement s) {
		Contract.Ensures(Contract.ValueAtReturn(out s) != null);
		IToken x; Expression e; var es = new List<Expression>();
		IToken startToken = null;
		
		Expect(99);
		x = t; startToken = t; 
		Expression(out e, false, true);
		es.Add(e); 
		while (la.kind == 25) {
			Get();
			Expression(out e, false, true);
			es.Add(e); 
		}
		Expect(32);
		s = new RevealStmt(new RangeToken(startToken, t), es);
		
	}

	void SkeletonStmt(out Statement s) {
		IToken dotdotdot; 
		Expect(98);
		dotdotdot = t; 
		Expect(32);
		s = new SkeletonStatement(new RangeToken(dotdotdot, t));
		errors.Deprecated(ErrorId.p_deprecated_statement_refinement, t, "the ... refinement feature in statements is deprecated");
		
	}

	void YieldStmt(out Statement/*!*/ s) {
		Expect(116);
		IToken yieldTok = t;
		List<AssignmentRhs> rhss = null;
		AssignmentRhs r;
		
		if (StartOf(32)) {
			Rhs(out r);
			rhss = new List<AssignmentRhs>();
			rhss.Add(r);
			
			while (la.kind == 25) {
				Get();
				Rhs(out r);
				rhss.Add(r); 
			}
		}
		Expect(32);
		s = new YieldStmt(new RangeToken(yieldTok, t), rhss);
		
	}

	void Rhs(out AssignmentRhs r) {
		Contract.Ensures(Contract.ValueAtReturn<AssignmentRhs>(out r) != null);
		IToken/*!*/ x, newToken;  Expression/*!*/ e;
		Type ty = new InferredTypeProxy();
		List<Expression> ee = null;
		List<ActualBinding> args = null;
		Expression arrayElementInit = null;
		List<Expression> display = null;
		r = dummyRhs;  // to please compiler
		Attributes attrs = null;
		IToken startToken = null;
		
		if (la.val == "new") {
			Expect(79);
			newToken = t; startToken = t; 
			if (la.kind == 86) {
				NewArray(out ee, out arrayElementInit, out display);
			} else if (StartOf(5)) {
				TypeAndToken(out x, out ty, false);
				if (la.kind == 86 || la.kind == 88) {
					if (la.kind == 86) {
						NewArray(out ee, out arrayElementInit, out display);
					} else {
						x = null; args = new List<ActualBinding>(); 
						Get();
						if (StartOf(4)) {
							ActualBindings(args);
						}
						Expect(89);
					}
				}
			} else SynErr(239);
			if (ee != null) {
			 if (display != null) {
			   r = new TypeRhs(newToken, ty, ee[0], display);
			 } else {
			   r = new TypeRhs(newToken, ty, ee, arrayElementInit);
			 }
			} else if (args != null) {
			 r = new TypeRhs(newToken, ty, args);
			} else {
			 r = new TypeRhs(newToken, ty);
			}
			
		} else if (la.kind == 95) {
			Get();
			r = new HavocRhs(t); startToken = t; 
		} else if (StartOf(4)) {
			Expression(out e, false, true);
			r = new ExprRhs(e); startToken = e.StartToken; 
		} else SynErr(240);
		while (la.kind == 83) {
			Attribute(ref attrs);
		}
		r.Attributes = attrs;
		r.RangeToken = new RangeToken(startToken ?? t, t); 
	}

	void Lhs(out Expression e) {
		e = dummyExpr;  // the assignment is to please the compiler, the dummy value to satisfy contracts in the event of a parse error
		
		if (StartOf(9)) {
			NameSegment(out e);
			while (la.kind == 30 || la.kind == 86 || la.kind == 88) {
				Suffix(ref e);
			}
		} else if (StartOf(38)) {
			ConstAtomExpression(out e);
			Suffix(ref e);
			while (la.kind == 30 || la.kind == 86 || la.kind == 88) {
				Suffix(ref e);
			}
		} else SynErr(241);
	}

	void NewArray(out List<Expression> ee, out Expression arrayElementInit, out List<Expression> display ) {
		ee = new List<Expression>();
		arrayElementInit = null;
		display = null;
		IToken x;
		
		Expect(86);
		x = t; 
		if (la.kind == 87) {
			Get();
			Expect(86);
			display = new List<Expression>(); 
			if (StartOf(4)) {
				Expressions(display);
			}
			Expect(87);
			ee.Add(new LiteralExpr(new AutoGeneratedToken(x), display.Count));
			
		} else if (StartOf(4)) {
			Expressions(ee);
			Expect(87);
			var eeCopy = ee;
			SystemModuleModifiers.Add(b => b.ArrayType(eeCopy.Count, new IntType(), true));
			
			if (la.kind == 86 || la.kind == 88) {
				if (la.kind == 88) {
					Get();
					Expression(out arrayElementInit, true, true);
					Expect(89);
				} else {
					Get();
					if (ee.Count > 1) {
					 SemErr(ErrorId.p_initializing_display_only_for_1D_arrays, t, "An initializing element display is allowed only for 1-dimensional arrays");
					}
					display = new List<Expression>();
					
					if (StartOf(4)) {
						Expressions(display);
					}
					Expect(87);
				}
			}
		} else SynErr(242);
		if (ee.Count == 0) {
		 // an error occurred while parsing, but we still want to make sure to return a nonempty "ee"
		 ee.Add(new LiteralExpr(new AutoGeneratedToken(x), 0));
		}
		
	}

	void ActualBindings(List<ActualBinding> bindings) {
		ActualBinding binding; 
		ActualBinding(out binding);
		bindings.Add(binding); 
		while (la.kind == 25) {
			Get();
			ActualBinding(out binding);
			bindings.Add(binding); 
		}
	}

	void Expressions(List<Expression> args) {
		Expression e; 
		Expression(out e, true, true);
		args.Add(e); 
		while (la.kind == 25) {
			Get();
			Expression(out e, true, true);
			args.Add(e); 
		}
	}

	void CasePatternLocal(out CasePattern<LocalVariable> pat, bool isGhost) {
		IToken id; List<CasePattern<LocalVariable>> arguments;
		LocalVariable local;
		pat = null;
		
		if (IsIdentParen()) {
			Ident(out id);
			Expect(88);
			arguments = new List<CasePattern<LocalVariable>>(); 
			if (StartOf(31)) {
				CasePatternLocal(out pat, isGhost);
				arguments.Add(pat); 
				while (la.kind == 25) {
					Get();
					CasePatternLocal(out pat, isGhost);
					arguments.Add(pat); 
				}
			}
			Expect(89);
			pat = new CasePattern<LocalVariable>(id, id.val, arguments); 
		} else if (la.kind == 88) {
			Get();
			id = t;
			arguments = new List<CasePattern<LocalVariable>>();
			
			if (StartOf(31)) {
				CasePatternLocal(out pat, isGhost);
				arguments.Add(pat); 
				while (la.kind == 25) {
					Get();
					CasePatternLocal(out pat, isGhost);
					arguments.Add(pat); 
				}
			}
			Expect(89);
			string ctor = SystemModuleManager.TupleTypeCtorName(arguments.Count);  //use the TupleTypeCtors
			pat = new CasePattern<LocalVariable>(id, ctor, arguments);
			
		} else if (StartOf(9)) {
			LocalIdentTypeOptional(out local, isGhost);
			pat = new CasePattern<LocalVariable>(local.Tok, local);
			
		} else SynErr(243);
		if (pat == null) {
		 pat = new CasePattern<LocalVariable>(t, "_ParseError", null);
		}
		
	}

	void AlternativeBlock(bool allowBindingGuards, out List<GuardedAlternative> alternatives, out bool usesOptionalBraces, out IToken endTok) {
		alternatives = new List<GuardedAlternative>();
		endTok = null;
		usesOptionalBraces = false;
		GuardedAlternative alt;
		
		if (la.kind == 84) {
			Get();
			usesOptionalBraces = true; 
			while (la.kind == 37) {
				AlternativeBlockCase(allowBindingGuards, out alt);
				alternatives.Add(alt); 
			}
			Expect(85);
		} else if (la.kind == 37) {
			AlternativeBlockCase(allowBindingGuards, out alt);
			alternatives.Add(alt); 
			while (la.kind == _case) {
				AlternativeBlockCase(allowBindingGuards, out alt);
				alternatives.Add(alt); 
			}
		} else SynErr(244);
		endTok = t; 
	}

	void BindingGuard(out Expression e, bool allowLambda) {
		var bvars = new List<BoundVar>();
		BoundVar bv;  IToken x;
		Attributes attrs = null;
		Expression body;
		
		IdentTypeOptional(out bv);
		bvars.Add(bv); x = bv.tok; 
		while (la.kind == 25) {
			Get();
			IdentTypeOptional(out bv);
			bvars.Add(bv); 
		}
		while (la.kind == 83) {
			Attribute(ref attrs);
		}
		Expect(29);
		Expression(out body, true, allowLambda);
		e = new ExistsExpr(x, new RangeToken(x, t), bvars, null, body, attrs); 
	}

	void Guard(out Expression e) {
		Expression/*!*/ ee;  e = null; 
		if (la.kind == 95) {
			Get();
			e = null; 
		} else if (IsParenStar()) {
			Expect(88);
			Expect(95);
			Expect(89);
			e = null; 
		} else if (StartOf(4)) {
			Expression(out ee, true, true);
			e = ee; 
		} else SynErr(245);
	}

	void AlternativeBlockCase(bool allowBindingGuards, out GuardedAlternative alt) {
		IToken x;
		Expression e; bool isBindingGuard;
		List<Statement> body;
		Attributes attrs = null;
		
		Expect(37);
		x = t; isBindingGuard = false; e = dummyExpr; 
		while (la.kind == 83) {
			Attribute(ref attrs);
		}
		if (allowBindingGuards && IsBindingGuard()) {
			BindingGuard(out e, false );
			isBindingGuard = true; 
		} else if (StartOf(4)) {
			Expression(out e, true, false);
		} else SynErr(246);
		Expect(33);
		body = new List<Statement>(); 
		while (!(StartOf(39))) {SynErr(247); Get();}
		while (IsNotEndOfCase()) {
			Stmt(body);
			while (!(StartOf(39))) {SynErr(248); Get();}
		}
		alt = new GuardedAlternative(x, isBindingGuard, e, body, attrs); 
	}

	void LoopSpec(List<AttributedExpression> invariants, List<Expression> decreases, ref List<FrameExpression> mod, ref Attributes decAttrs, ref Attributes modAttrs) {
		while (la.kind == 44 || la.kind == 46 || la.kind == 71) {
			if (la.kind == 46) {
				while (!(la.kind == 0 || la.kind == 46)) {SynErr(249); Get();}
				InvariantClause(invariants);
			} else if (la.kind == 44) {
				while (!(la.kind == 0 || la.kind == 44)) {SynErr(250); Get();}
				DecreasesClause(decreases, ref decAttrs, true, true);
			} else {
				while (!(la.kind == 0 || la.kind == 71)) {SynErr(251); Get();}
				ModifiesClause(ref mod, ref modAttrs, true, false);
			}
		}
	}

	void ForLoopDirection(out bool goingUp) {
		goingUp = true; 
		Expect(1);
		if (t.val == "downto") {
		 goingUp = false;
		} else if (t.val != "to") {
		 SemErr(ErrorId.p_to_or_downto, t, "Expected 'to' or 'downto'");
		}
		
	}

	void SingleExtendedPattern(out ExtendedPattern pat) {
		IToken id; List<ExtendedPattern> arguments;
		Expression lit; BoundVar bv;
		pat = null;
		
		if (la.kind == 88) {
			Get();
			id = t;
			arguments = new List<ExtendedPattern>(); 
			if (StartOf(40)) {
				ExtendedPattern(out pat);
				arguments.Add(pat); 
				while (la.kind == 25) {
					Get();
					ExtendedPattern(out pat);
					arguments.Add(pat); 
				}
			}
			Expect(89);
			SystemModuleModifiers.Add(b => b.TupleType(id, arguments.Count, true));
			//use the TupleTypeCtors
			string ctor = SystemModuleManager.TupleTypeCtorName(arguments.Count);
			pat = new IdPattern(id, ctor, arguments);
			
		} else if (IsIdentParen()) {
			Ident(out id);
			arguments = new List<ExtendedPattern>(); 
			Expect(88);
			if (StartOf(40)) {
				ExtendedPattern(out pat);
				arguments.Add(pat); 
				while (la.kind == 25) {
					Get();
					ExtendedPattern(out pat);
					arguments.Add(pat); 
				}
			}
			Expect(89);
			pat = new IdPattern(id, id.val, arguments, false, true); 
		} else if (StartOf(41)) {
			PossiblyNegatedLiteralExpr(out lit);
			pat = new LitPattern(lit.tok, lit); 
		} else if (StartOf(9)) {
			IdentTypeOptional(out bv);
			pat = new IdPattern(bv.tok, bv.Name, bv.SyntacticType, null); 
		} else SynErr(252);
		if (pat == null) {
		 pat = new IdPattern(t, "_ParseError", null);
		}
		
	}

	void ExtendedPattern(out ExtendedPattern pat) {
		List<ExtendedPattern> branches = null;
		ExtendedPattern branch = null; 
		if (la.kind == 26) {
			Get();
		}
		SingleExtendedPattern(out branch);
		while (la.kind == 26) {
			Get();
			branches ??= new() { branch }; 
			SingleExtendedPattern(out branch);
			branches.Add(branch); 
		}
		pat = branches == null ? branch : new DisjunctivePattern(branches[0].Tok, branches); 
	}

	void PossiblyNegatedLiteralExpr(out Expression e) {
		BigInteger n; BaseTypes.BigDec d;
		e = dummyExpr;
		
		if (la.kind == 104) {
			Get();
			var x = t; 
			if (la.kind == 2 || la.kind == 3) {
				Nat(out n);
				e = new NegationExpression(x, new LiteralExpr(t, n)); 
			} else if (la.kind == 4) {
				Dec(out d);
				e = new NegationExpression(x, new LiteralExpr(t, d)); 
			} else SynErr(253);
		} else if (StartOf(42)) {
			LiteralExpression(out e);
		} else SynErr(254);
	}

	void CaseStmt(out NestedMatchCaseStmt/*!*/ c) {
		Contract.Ensures(Contract.ValueAtReturn(out c) != null);
		IToken/*!*/ x;
		ExtendedPattern/*!*/ pat = null;
		var body = new List<Statement/*!*/>();
		Attributes attrs = null;
		
		Expect(37);
		x = t; 
		while (la.kind == 83) {
			Attribute(ref attrs);
		}
		ExtendedPattern(out pat);
		
		Expect(33);
		while (!(StartOf(39))) {SynErr(255); Get();}
		while (IsNotEndOfCase()) {
			Stmt(body);
			while (!(StartOf(39))) {SynErr(256); Get();}
		}
		c = new NestedMatchCaseStmt(x, pat, body, attrs); 
	}

	void QuantifierDomain(out List<BoundVar> bvars, out Attributes attrs, out Expression range, bool allowLemma, bool allowLambda, bool allowBitwiseOps) {
		List<QuantifiedVar> qvars = new List<QuantifiedVar>();
		QuantifiedVar/*!*/ qv;
		attrs = null;
		range = null;
		
		QuantifierVariableDecl(out qv, ref attrs, allowLemma, allowLambda, allowBitwiseOps);
		qvars.Add(qv); 
		while (IsQuantifierVariableDecl(qv)) {
			Expect(25);
			QuantifierVariableDecl(out qv, ref attrs, allowLemma, allowLambda, allowBitwiseOps);
			qvars.Add(qv); 
		}
		QuantifiedVar.ExtractSingleRange(qvars, out bvars, out range); 
	}

	void CalcOp(out IToken x, out CalcStmt.CalcOp/*!*/ op) {
		var binOp = BinaryExpr.Opcode.Eq; // Returns Eq if parsing fails because it is compatible with any other operator
		Expression k = null;
		x = null;
		
		switch (la.kind) {
		case 93: {
			Get();
			x = t;  binOp = BinaryExpr.Opcode.Eq; 
			if (la.kind == 129) {
				Get();
				Expect(86);
				Expression(out k, true, true);
				Expect(87);
			}
			break;
		}
		case 90: {
			Get();
			x = t;  binOp = BinaryExpr.Opcode.Lt; 
			break;
		}
		case 91: {
			Get();
			x = t;  binOp = BinaryExpr.Opcode.Gt; 
			break;
		}
		case 130: {
			Get();
			x = t;  binOp = BinaryExpr.Opcode.Le; 
			break;
		}
		case 131: {
			Get();
			x = t;  binOp = BinaryExpr.Opcode.Ge; 
			break;
		}
		case 94: {
			Get();
			x = t;  binOp = BinaryExpr.Opcode.Neq; 
			break;
		}
		case 132: {
			EquivOp();
			x = t;  binOp = BinaryExpr.Opcode.Iff; 
			break;
		}
		case 133: {
			ImpliesOp();
			x = t;  binOp = BinaryExpr.Opcode.Imp; 
			break;
		}
		case 134: {
			ExpliesOp();
			x = t;  binOp = BinaryExpr.Opcode.Exp; 
			break;
		}
		default: SynErr(257); break;
		}
		if (k == null) {
		 op = new Microsoft.Dafny.CalcStmt.BinaryCalcOp(binOp);
		} else {
		 op = new Microsoft.Dafny.CalcStmt.TernaryCalcOp(k);
		}
		
	}

	void EquivOp() {
		Expect(132);
	}

	void ImpliesOp() {
		Expect(133);
	}

	void ExpliesOp() {
		Expect(134);
	}

	void AndOp() {
		Expect(135);
	}

	void OrOp() {
		Expect(136);
	}

	void NegOp() {
		Expect(115);
	}

	void Forall() {
		Expect(127);
	}

	void Exists() {
		Expect(137);
	}

	void QSep() {
		Expect(27);
	}

	void EquivExpression(out Expression e0, bool allowLemma, bool allowLambda, bool allowBitwiseOps) {
		Contract.Ensures(Contract.ValueAtReturn(out e0) != null); IToken/*!*/ x;  Expression/*!*/ e1; 
		ImpliesExpliesExpression(out e0, allowLemma, allowLambda, allowBitwiseOps);
		while (IsEquivOp()) {
			EquivOp();
			x = t; 
			ImpliesExpliesExpression(out e1, allowLemma, allowLambda, allowBitwiseOps);
			var startToken = e0.StartToken;
			e0 = new BinaryExpr(x, BinaryExpr.Opcode.Iff, e0, e1);
			e0.RangeToken = new RangeToken(startToken, t); 
		}
	}

	void ImpliesExpliesExpression(out Expression e0, bool allowLemma, bool allowLambda, bool allowBitwiseOps) {
		Contract.Ensures(Contract.ValueAtReturn(out e0) != null);
		IToken/*!*/ x;
		Expression/*!*/ e1; 
		LogicalExpression(out e0, allowLemma, allowLambda, allowBitwiseOps);
		if (IsImpliesOp() || IsExpliesOp()) {
			if (la.kind == 133) {
				ImpliesOp();
				x = t; 
				ImpliesExpression(out e1, allowLemma, allowLambda, allowBitwiseOps);
				var startToken = e0.StartToken;
				e0 = new BinaryExpr(x, BinaryExpr.Opcode.Imp, e0, e1);
				e0.RangeToken = new RangeToken(startToken, t); 
			} else if (la.kind == 134) {
				ExpliesOp();
				x = t; 
				LogicalExpression(out e1, allowLemma, allowLambda, allowBitwiseOps);
				var startToken = e0.StartToken;
				e0 = new BinaryExpr(x, BinaryExpr.Opcode.Exp, e1, e0);
				e0.RangeToken = new RangeToken(startToken, t); 
				while (IsExpliesOp()) {
					ExpliesOp();
					x = t; 
					LogicalExpression(out e1, allowLemma, allowLambda, allowBitwiseOps);
					startToken = e0.StartToken;
					e0 = new BinaryExpr(x, BinaryExpr.Opcode.Exp, e1, e0);
					e0.RangeToken = new RangeToken(startToken, t);
					
				}
				if (IsImpliesOp()) {
					ImpliesOp();
					SemErr(ErrorId.p_ambiguous_implies, t, "Ambiguous use of ==> and <==. Use parentheses to disambiguate."); 
					LogicalExpression(out e1, allowLemma, allowLambda, allowBitwiseOps);
					while (IsImpliesOp() || IsExpliesOp()) {
						if (la.kind == 133) {
							ImpliesOp();
						} else if (la.kind == 134) {
							ExpliesOp();
						} else SynErr(258);
						LogicalExpression(out e1, allowLemma, allowLambda, allowBitwiseOps);
					}
				}
			} else SynErr(259);
		}
	}

	void LogicalExpression(out Expression e0, bool allowLemma, bool allowLambda, bool allowBitwiseOps) {
		Contract.Ensures(Contract.ValueAtReturn(out e0) != null); IToken/*!*/ x = null;  Expression/*!*/ e1;
		Expression first;
		IToken startToken = null;
		IToken/*!*/ firstOp = null;
		IToken/*!*/ prefixOp = null;
		e0 = dummyExpr; /* mute the warning */
		
		if (la.kind == 135 || la.kind == 136) {
			if (la.kind == 135) {
				AndOp();
			} else {
				OrOp();
			}
			firstOp = t; prefixOp = t; x = t; 
		}
		RelationalExpression(out e0, allowLemma, allowLambda, allowBitwiseOps);
		first = e0; 
		while (IsAndOp() || IsOrOp()) {
			if (la.kind == 135) {
				AndOp();
			} else if (la.kind == 136) {
				OrOp();
			} else SynErr(260);
			x = t; 
			if (firstOp == null) firstOp = t; 
			if (firstOp.kind != t.kind) SemErr(ErrorId.p_ambiguous_and_or, t, "Ambiguous use of && and ||. Use parentheses to disambiguate.");
			
			RelationalExpression(out e1, allowLemma, allowLambda, allowBitwiseOps);
			startToken = e0.StartToken;
			e0 = new BinaryExpr(x, firstOp.val == "&&" ? BinaryExpr.Opcode.And : BinaryExpr.Opcode.Or, e0, e1);
			e0.RangeToken = new RangeToken(startToken, t);
			
		}
		if (e0 == first && prefixOp != null) {
		 // There was only one conjunct. To make sure that the type checker still checks it to
		 // be a boolean, we conjoin "true" of "false" to its left.
		 if (firstOp.val == "&&") e0 = new BinaryExpr(x, BinaryExpr.Opcode.And, new LiteralExpr(new AutoGeneratedToken(x), true), e0);
		 else e0 = new BinaryExpr(x, BinaryExpr.Opcode.Or, new LiteralExpr(new AutoGeneratedToken(x), false), e0);
		 e0.RangeToken = new RangeToken(firstOp, t);
		 e0.FormatTokens = new[] { firstOp };
		} else if(prefixOp != null) {
		 e0.RangeToken = new RangeToken(prefixOp, e0.EndToken);
		}
		
	}

	void ImpliesExpression(out Expression e0, bool allowLemma, bool allowLambda, bool allowBitwiseOps) {
		Contract.Ensures(Contract.ValueAtReturn(out e0) != null); IToken/*!*/ x;  Expression/*!*/ e1; 
		LogicalExpression(out e0, allowLemma, allowLambda, allowBitwiseOps);
		if (IsImpliesOp() || IsExpliesOp()) {
			if (la.kind == 133) {
				ImpliesOp();
			} else if (la.kind == 134) {
				ExpliesOp();
				SemErr(ErrorId.p_ambiguous_implies_2, t, "Ambiguous use of ==> and <==. Use parentheses to disambiguate."); 
			} else SynErr(261);
			x = t; 
			ImpliesExpression(out e1, allowLemma, allowLambda, allowBitwiseOps);
			var startToken = e0.StartToken;
			e0 = new BinaryExpr(x, BinaryExpr.Opcode.Imp, e0, e1); 
			e0.RangeToken = new RangeToken(startToken, t);
		}
	}

	void RelationalExpression(out Expression e, bool allowLemma, bool allowLambda, bool allowBitwiseOps) {
		Contract.Ensures(Contract.ValueAtReturn(out e) != null);
		IToken x = null;  Expression e0, e1 = null;  BinaryExpr.Opcode op;
		List<Expression> chain = null;
		List<BinaryExpr.Opcode> ops = null;
		List<IToken> opLocs = null;
		List<Expression/*?*/> prefixLimits = null;
		IToken startToken = null;
		Expression k;
		int kind = 0;  // 0 ("uncommitted") indicates chain of ==, possibly with one !=
		              // 1 ("ascending")   indicates chain of ==, <, <=, possibly with one !=
		              // 2 ("descending")  indicates chain of ==, >, >=, possibly with one !=
		              // 3 ("illegal")     indicates illegal chain
		              // 4 ("disjoint")    indicates chain of disjoint set operators
		bool hasSeenNeq = false;
		
		ShiftTerm(out e0, allowLemma, allowLambda, allowBitwiseOps);
		e = e0; startToken = e0.StartToken; 
		if (IsRelOp()) {
			RelOp(out x, out op, out k);
			ShiftTerm(out e1, allowLemma, allowLambda, allowBitwiseOps);
			startToken = e0.StartToken;
			if (k == null) {
			 e = new BinaryExpr(x, op, e0, e1);
			} else {
			 Contract.Assert(op == BinaryExpr.Opcode.Eq || op == BinaryExpr.Opcode.Neq);
			 e = new TernaryExpr(x, op == BinaryExpr.Opcode.Eq ? TernaryExpr.Opcode.PrefixEqOp : TernaryExpr.Opcode.PrefixNeqOp, k, e0, e1);
			}
			e.RangeToken = new RangeToken(startToken, t);
			
			while (IsRelOp()) {
				if (chain == null) {
				 chain = new List<Expression>();
				 ops = new List<BinaryExpr.Opcode>();
				 opLocs = new List<IToken>();
				 prefixLimits = new List<Expression>();
				 chain.Add(e0); ops.Add(op); opLocs.Add(x); prefixLimits.Add(k); chain.Add(e1);
				 switch (op) {
				   case BinaryExpr.Opcode.Eq:
				     kind = 0;  break;
				   case BinaryExpr.Opcode.Neq:
				     kind = 0;  hasSeenNeq = true;  break;
				   case BinaryExpr.Opcode.Lt:
				   case BinaryExpr.Opcode.Le:
				     kind = 1;  break;
				   case BinaryExpr.Opcode.Gt:
				   case BinaryExpr.Opcode.Ge:
				     kind = 2;  break;
				   case BinaryExpr.Opcode.Disjoint:
				     kind = 4;  break;
				   default:
				     kind = 3;  break;
				 }
				}
				
				RelOp(out x, out op, out k);
				switch (op) {
				 case BinaryExpr.Opcode.Eq:
				   if (kind != 0 && kind != 1 && kind != 2) { SemErr(ErrorId.p_invalid_equal_chaining, x, "chaining not allowed from the previous operator"); kind = 3; }
				   break;
				 case BinaryExpr.Opcode.Neq:
				   if (hasSeenNeq) { SemErr(ErrorId.p_invalid_notequal_chaining, x, "a chain cannot have more than one != operator"); kind = 3; }
				   else if (kind != 0 && kind != 1 && kind != 2) { SemErr(ErrorId.p_invalid_operator_in_chain, x, "this operator cannot continue this chain"); kind = 3; }
				   hasSeenNeq = true;  break;
				 case BinaryExpr.Opcode.Lt:
				 case BinaryExpr.Opcode.Le:
				   if (kind == 0) { kind = 1; }
				   else if (kind != 1) { SemErr(ErrorId.p_invalid_descending_chaining, x, "this operator chain cannot continue with an ascending operator"); kind = 3; }
				   break;
				 case BinaryExpr.Opcode.Gt:
				 case BinaryExpr.Opcode.Ge:
				   if (kind == 0) { kind = 2; }
				   else if (kind != 2) { SemErr(ErrorId.p_invalid_ascending_chaining, x, "this operator chain cannot continue with a descending operator"); kind = 3; }
				   break;
				 case BinaryExpr.Opcode.Disjoint:
				   if (kind != 4) { SemErr(ErrorId.p_invalid_disjoint_chaining, x, "can only chain disjoint (!!) with itself"); kind = 3; }
				   break;
				 default:
				   SemErr(ErrorId.p_operator_does_not_chain, x, "this operator cannot be part of a chain");
				   kind = 3;  break;
				}
				
				ShiftTerm(out e1, allowLemma, allowLambda, allowBitwiseOps);
				ops.Add(op); opLocs.Add(x); prefixLimits.Add(k); chain.Add(e1);
				
			}
		}
		if (chain != null && kind != 3) {
		 e = new ChainingExpression(opLocs[0], chain, ops, opLocs, prefixLimits);
		}
		e.RangeToken = new RangeToken(startToken, t);
		
	}

	void ShiftTerm(out Expression e0, bool allowLemma, bool allowLambda, bool allowBitwiseOps) {
		Contract.Ensures(Contract.ValueAtReturn(out e0) != null);
		IToken x = Token.NoToken;  Expression e1;  BinaryExpr.Opcode op = BinaryExpr.Opcode.LeftShift/*(dummy)*/;
		
		Term(out e0, allowLemma, allowLambda, allowBitwiseOps);
		while (IsShiftOp()) {
			if (la.kind == 90) {
				Get();
				x = t;  op = BinaryExpr.Opcode.LeftShift; 
				Expect(90);
				t.val = "<<";
				t.pos = x.pos;
				t.col = x.col;
				t.Prev = x.Prev;
				x.Prev.Next = t;
				x = t; 
			} else if (la.kind == 91) {
				Get();
				x = t;  op = BinaryExpr.Opcode.RightShift; 
				Expect(91);
				t.val = ">>";
				t.pos = x.pos;
				t.col = x.col;
				t.Prev = x.Prev;
				x.Prev.Next = t;
				x = t; 
			} else SynErr(262);
			Term(out e1, allowLemma, allowLambda, allowBitwiseOps);
			var startToken = e0.StartToken;
			e0 = new BinaryExpr(x, op, e0, e1);
			e0.RangeToken = new RangeToken(startToken, t);
			
		}
	}

	void RelOp(out IToken/*!*/ x, out BinaryExpr.Opcode op, out Expression k) {
		Contract.Ensures(Contract.ValueAtReturn(out x) != null);
		x = Token.NoToken;  op = BinaryExpr.Opcode.Add/*(dummy)*/;
		IToken y;
		k = null;
		
		switch (la.kind) {
		case 93: {
			Get();
			x = t;  op = BinaryExpr.Opcode.Eq; 
			if (la.kind == 129) {
				Get();
				Expect(86);
				Expression(out k, true, true);
				Expect(87);
			}
			break;
		}
		case 90: {
			Get();
			x = t;  op = BinaryExpr.Opcode.Lt;  
			break;
		}
		case 91: {
			Get();
			x = t;  op = BinaryExpr.Opcode.Gt;  
			break;
		}
		case 130: {
			Get();
			x = t;  op = BinaryExpr.Opcode.Le;  
			break;
		}
		case 131: {
			Get();
			x = t;  op = BinaryExpr.Opcode.Ge;  
			break;
		}
		case 94: {
			Get();
			x = t;  op = BinaryExpr.Opcode.Neq;  
			if (la.kind == 129) {
				Get();
				Expect(86);
				Expression(out k, true, true);
				Expect(87);
			}
			break;
		}
		case 43: {
			Get();
			x = t;  op = BinaryExpr.Opcode.In; 
			break;
		}
		case 97: {
			Get();
			x = t;  op = BinaryExpr.Opcode.NotIn; 
			break;
		}
		case 115: {
			Get();
			x = t;  y = Token.NoToken; 
			if (la.val == "!") {
				Expect(115);
				y = t; 
			}
			if (y == Token.NoToken) {
			 SemErr(ErrorId.p_bang_not_a_relational_op, x, "invalid relational operator");
			} else if (y.pos != x.pos + 1) {
			 SemErr(ErrorId.p_invalid_relational_op, new RangeToken(x,y), "invalid relational operator (perhaps you intended \"!!\" with no intervening whitespace?)");
			} else {
			 x.val = "!!";
			 y.val = "";
			 op = BinaryExpr.Opcode.Disjoint;
			}
			
			break;
		}
		default: SynErr(263); break;
		}
	}

	void Term(out Expression e0, bool allowLemma, bool allowLambda, bool allowBitwiseOps) {
		Contract.Ensures(Contract.ValueAtReturn(out e0) != null); IToken/*!*/ x;  Expression/*!*/ e1;  BinaryExpr.Opcode op; 
		Factor(out e0, allowLemma, allowLambda, allowBitwiseOps);
		while (IsAddOp()) {
			AddOp(out x, out op);
			Factor(out e1, allowLemma, allowLambda, allowBitwiseOps);
			var startToken = e0.StartToken;
			e0 = new BinaryExpr(x, op, e0, e1);
			e0.RangeToken = new RangeToken(startToken, t); 
		}
	}

	void Factor(out Expression e0, bool allowLemma, bool allowLambda, bool allowBitwiseOps) {
		Contract.Ensures(Contract.ValueAtReturn(out e0) != null); IToken/*!*/ x;  Expression/*!*/ e1;  BinaryExpr.Opcode op; 
		BitvectorFactor(out e0, allowLemma, allowLambda, allowBitwiseOps);
		while (IsMulOp()) {
			MulOp(out x, out op);
			BitvectorFactor(out e1, allowLemma, allowLambda, allowBitwiseOps);
			var startToken = e0.StartToken;
			e0 = new BinaryExpr(x, op, e0, e1);
			e0.RangeToken = new RangeToken(startToken, t);
			
		}
	}

	void AddOp(out IToken x, out BinaryExpr.Opcode op) {
		Contract.Ensures(Contract.ValueAtReturn(out x) != null); x = Token.NoToken;  op=BinaryExpr.Opcode.Add/*(dummy)*/; 
		if (la.kind == 114) {
			Get();
			x = t;  op = BinaryExpr.Opcode.Add; 
		} else if (la.kind == 104) {
			Get();
			x = t;  op = BinaryExpr.Opcode.Sub; 
		} else SynErr(264);
	}

	void BitvectorFactor(out Expression e0, bool allowLemma, bool allowLambda, bool allowBitwiseOps) {
		Contract.Ensures(Contract.ValueAtReturn(out e0) != null); IToken/*!*/ x = null;  Expression/*!*/ e1;  BinaryExpr.Opcode op; bool ambig = false; op = BinaryExpr.Opcode.BitwiseAnd; 
		AsExpression(out e0, allowLemma, allowLambda, allowBitwiseOps);
		if (allowBitwiseOps && IsBitwiseOp()) {
			if (la.kind == 140) {
				Get();
				op = BinaryExpr.Opcode.BitwiseAnd; x = t; 
			} else if (la.kind == 26) {
				Get();
				op = BinaryExpr.Opcode.BitwiseOr; x = t; 
			} else if (la.kind == 141) {
				Get();
				op = BinaryExpr.Opcode.BitwiseXor; x = t; 
			} else SynErr(265);
			AsExpression(out e1, allowLemma, allowLambda, allowBitwiseOps);
			var startToken = e0.StartToken; e0 = new BinaryExpr(x, op, e0, e1); e0.RangeToken = new RangeToken(startToken, t); 
			while (IsBitwiseOp()) {
				if (la.kind == 140) {
					Get();
				} else if (la.kind == 26) {
					Get();
				} else if (la.kind == 141) {
					Get();
				} else SynErr(266);
				if (x.kind != t.kind && !ambig) { ambig = true; SemErr(ErrorId.p_ambiguous_bitop, t, "Ambiguous use of &, |, ^. Use parentheses to disambiguate."); }
				x = t; 
				AsExpression(out e1, allowLemma, allowLambda, allowBitwiseOps);
				startToken = e0.StartToken; e0 = new BinaryExpr(x, op, e0, e1); e0.RangeToken = new RangeToken(startToken, t); 
			}
		}
	}

	void MulOp(out IToken x, out BinaryExpr.Opcode op) {
		Contract.Ensures(Contract.ValueAtReturn(out x) != null); x = Token.NoToken;  op = BinaryExpr.Opcode.Add/*(dummy)*/; 
		if (la.kind == 95) {
			Get();
			x = t;  op = BinaryExpr.Opcode.Mul; 
		} else if (la.kind == 138) {
			Get();
			x = t;  op = BinaryExpr.Opcode.Div; 
		} else if (la.kind == 139) {
			Get();
			x = t;  op = BinaryExpr.Opcode.Mod; 
		} else SynErr(267);
	}

	void AsExpression(out Expression e, bool allowLemma, bool allowLambda, bool allowBitwiseOps) {
		IToken tok; IToken x; Type toType; 
		UnaryExpression(out e, allowLemma, allowLambda, allowBitwiseOps);
		while (IsAsOrIs()) {
			if (la.kind == 40) {
				Get();
				tok = t; 
				TypeAndToken(out x, out toType, true);
				e = new ConversionExpr(tok, e, toType) { RangeToken = new RangeToken(e.StartToken, t)}; 
			} else if (la.kind == 41) {
				Get();
				tok = t; 
				TypeAndToken(out x, out toType, true);
				e = new TypeTestExpr(tok, e, toType) { RangeToken = new RangeToken(e.StartToken, t)}; 
			} else SynErr(268);
		}
	}

	void UnaryExpression(out Expression e, bool allowLemma, bool allowLambda, bool allowBitwiseOps) {
		Contract.Ensures(Contract.ValueAtReturn(out e) != null); IToken/*!*/ x;  e = dummyExpr; 
		if (la.kind == 104) {
			Get();
			x = t; 
			UnaryExpression(out e, allowLemma, allowLambda, allowBitwiseOps);
			e = new NegationExpression(x, e) { RangeToken = new RangeToken(x, t) }; 
		} else if (la.kind == 115) {
			NegOp();
			x = t; 
			UnaryExpression(out e, allowLemma, allowLambda, allowBitwiseOps);
			e = new UnaryOpExpr(x, UnaryOpExpr.Opcode.Not, e) { RangeToken = new RangeToken(x, t) }; 
		} else if (StartOf(43)) {
			PrimaryExpression(out e, allowLemma, allowLambda, allowBitwiseOps);
		} else SynErr(269);
	}

	void PrimaryExpression(out Expression e, bool allowLemma, bool allowLambda, bool allowBitwiseOps) {
		Contract.Ensures(Contract.ValueAtReturn(out e) != null); e = dummyExpr; 
		if (ExprIsMapDisplay()) {
			MapDisplayExpr(out e);
			while (IsSuffix()) {
				Suffix(ref e);
			}
		} else if (ExprIsSetDisplay()) {
			SetDisplayExpr(out e);
			while (IsSuffix()) {
				Suffix(ref e);
			}
		} else if (IsLambda(allowLambda)) {
			LambdaExpression(out e, allowLemma, allowBitwiseOps);
		} else if (StartOf(44)) {
			EndlessExpression(out e, allowLemma, allowLambda, allowBitwiseOps);
		} else if (StartOf(9)) {
			NameSegment(out e);
			while (IsSuffix()) {
				Suffix(ref e);
			}
		} else if (la.kind == 19 || la.kind == 86) {
			SeqDisplayExpr(out e);
			while (IsSuffix()) {
				Suffix(ref e);
			}
		} else if (StartOf(38)) {
			ConstAtomExpression(out e);
			while (IsSuffix()) {
				Suffix(ref e);
			}
		} else SynErr(270);
	}

	void MapDisplayExpr(out Expression e) {
		Contract.Ensures(Contract.ValueAtReturn(out e) != null);
		List<ExpressionPair/*!*/>/*!*/ elements= new List<ExpressionPair/*!*/>() ;
		e = dummyExpr;
		
		if (la.kind == 20) {
			Get();
		} else if (la.kind == 21) {
			Get();
		} else SynErr(271);
		IToken mapToken = t; 
		Expect(86);
		if (StartOf(4)) {
			MapLiteralExpressions(out elements);
		}
		e = new MapDisplayExpr(mapToken, mapToken.kind == _map, elements);
		Expect(87);
		e.RangeToken = new RangeToken(mapToken, t); 
	}

	void Suffix(ref Expression e) {
		Contract.Requires(e != null); Contract.Ensures(e!=null);
		IToken id, x;
		Expression e0 = null;  Expression e1 = null;  Expression ee;  bool anyDots = false;
		List<Expression> multipleLengths = null; bool takeRest = false; // takeRest is relevant only if multipleLengths is non-null
		List<Expression> multipleIndices = null;
		List<Tuple<IToken, string, Expression>> updates;
		var startToken = e.StartToken;
		Expression v;
		
		if (la.kind == 30) {
			Get();
			if (la.kind == 88) {
				Get();
				x = t; updates = new List<Tuple<IToken, string, Expression>>(); 
				MemberBindingUpdate(out id, out v);
				updates.Add(Tuple.Create(id, id.val, v)); 
				while (la.kind == 25) {
					Get();
					MemberBindingUpdate(out id, out v);
					updates.Add(Tuple.Create(id, id.val, v)); 
				}
				Expect(89);
				e = new DatatypeUpdateExpr(x, e, updates) { RangeToken = new RangeToken(startToken, t)}; 
			} else if (StartOf(45)) {
				DotSuffix(out id, out x);
				if (x != null) {
				 // process id as a Suffix in its own right
				 e = new ExprDotName(id, e, id.val, null) { RangeToken = new RangeToken(startToken, t)};
				 id = x;  // move to the next Suffix
				}
				IToken openParen = null;  List<Type> typeArgs = null;
				List<ActualBinding> args = null;
				IToken atLabel = null;
				
				if (IsGenericInstantiation(true)) {
					typeArgs = new List<Type>(); 
					GenericInstantiation(typeArgs);
					if (la.kind == 96) {
						AtCall(out atLabel, out openParen, out args);
					}
				} else if (la.kind == 129) {
					HashCall(id, out openParen, out typeArgs, out args);
				} else if (StartOf(46)) {
					if (la.kind == 96) {
						AtCall(out atLabel, out openParen, out args);
					}
				} else SynErr(272);
				e = new ExprDotName(id, e, id.val, typeArgs) {
				 RangeToken = new RangeToken(startToken, id)
				};
				if (openParen != null) {
				 e = new ApplySuffix(openParen, atLabel, e, args, t) {
				   RangeToken = new RangeToken(startToken, t)
				 };
				} else {
				 Contract.Assert(atLabel == null);
				}
				
			} else SynErr(273);
		} else if (la.kind == 86) {
			Get();
			x = t; 
			if (StartOf(4)) {
				Expression(out ee, true, true);
				e0 = ee; 
				if (la.kind == 150) {
					Get();
					anyDots = true; 
					if (StartOf(4)) {
						Expression(out ee, true, true);
						e1 = ee; 
					}
				} else if (la.kind == 28) {
					Get();
					Expression(out ee, true, true);
					e1 = ee; 
				} else if (la.kind == 24) {
					Get();
					multipleLengths = new List<Expression>();
					multipleLengths.Add(e0);  // account for the Expression read before the colon
					takeRest = true;
					
					if (StartOf(4)) {
						Expression(out ee, true, true);
						multipleLengths.Add(ee); takeRest = false; 
						while (IsNonFinalColon()) {
							Expect(24);
							Expression(out ee, true, true);
							multipleLengths.Add(ee); 
						}
						if (la.kind == 24) {
							Get();
							takeRest = true; 
						}
					}
				} else if (la.kind == 25 || la.kind == 87) {
					while (la.kind == 25) {
						Get();
						Expression(out ee, true, true);
						if (multipleIndices == null) {
						 multipleIndices = new List<Expression>();
						 multipleIndices.Add(e0);
						}
						multipleIndices.Add(ee);
						
					}
				} else SynErr(274);
			} else if (la.kind == 150) {
				Get();
				anyDots = true; 
				if (StartOf(4)) {
					Expression(out ee, true, true);
					e1 = ee; 
				}
			} else SynErr(275);
			Expect(87);
			if (multipleIndices != null) {
			 e = new MultiSelectExpr(x, e, multipleIndices);
			 // make sure an array class with this dimensionality exists
			 SystemModuleModifiers.Add(b => b.ArrayType(multipleIndices.Count, new IntType(), true));
			} else {
			 if (!anyDots && e0 == null) {
			   /* a parsing error occurred */
			   e0 = dummyExpr;
			 }
			 Contract.Assert(anyDots || e0 != null);
			 if (anyDots) {
			   //Contract.Assert(e0 != null || e1 != null);
			   e = new SeqSelectExpr(x, false, e, e0, e1, t);
			 } else if (multipleLengths != null) {
			   Expression prev = null;
			   List<Expression> seqs = new List<Expression>();
			    foreach (var len in multipleLengths) {
			      var end = prev == null ? len : new BinaryExpr(x, BinaryExpr.Opcode.Add, prev, len) {
			        RangeToken = new RangeToken(prev.StartToken, len.EndToken)
			      };
			      seqs.Add(new SeqSelectExpr(x, false, e, prev, end, t) {
			        RangeToken = new RangeToken(e.StartToken, t)
			      });
			      prev = end;
			    }
			   if (takeRest) {
			     seqs.Add(new SeqSelectExpr(x, false, e, prev, null, t) {
			       RangeToken = new RangeToken(e.StartToken, t)
			     });
			   }
			   e = new SeqDisplayExpr(x, seqs);
			 } else if (e1 == null) {
			   Contract.Assert(e0 != null);
			   e = new SeqSelectExpr(x, true, e, e0, null, t);
			 } else {
			   Contract.Assert(e0 != null);
			   e = new SeqUpdateExpr(x, e, e0, e1);
			 }
			}
			e.RangeToken = new RangeToken(startToken, t);
			
		} else if (la.kind == 88) {
			Get();
			IToken openParen = t; var args = new List<ActualBinding>(); 
			if (StartOf(4)) {
				ActualBindings(args);
			}
			Expect(89);
			e = new ApplySuffix(openParen, null, e, args, t);
			e.RangeToken = new RangeToken(startToken, t);
			
		} else SynErr(276);
	}

	void SetDisplayExpr(out Expression e) {
		Contract.Ensures(Contract.ValueAtReturn(out e) != null);
		IToken token = null;
		IToken x = null, startToken = null;
		e = dummyExpr;
		
		if (la.kind == 17 || la.kind == 18) {
			if (la.kind == 17) {
				Get();
			} else {
				Get();
			}
			token = t; startToken = t; x = t; 
		}
		if (la.kind == 84) {
			Get();
			token = token ?? t;
			startToken = startToken ?? t;
			x = token; 
			List<Expression> elements = new List<Expression/*!*/>();
			
			if (StartOf(4)) {
				Expressions(elements);
			}
			if (token.kind == _iset) {
			 e = new SetDisplayExpr(x, false, elements);
			} else if (token.kind == _multiset) {
			 e = new MultiSetDisplayExpr(x, elements);
			} else {
			 e = new SetDisplayExpr(x, true, elements);
			}
			
			Expect(85);
		} else if (la.kind == 88) {
			Get();
			x = t; startToken = startToken ?? t; 
			Expression(out e, true, true);
			if (token == null || token.kind != _multiset) {
			 SemErr(ErrorId.p_must_be_multiset, x, "A forming expression must be a multiset");
			}
			e = new MultiSetFormingExpr(x, e);
			
			Expect(89);
		} else SynErr(277);
		e.RangeToken = new RangeToken(startToken, t); 
	}

	void LambdaExpression(out Expression e, bool allowLemma, bool allowBitwiseOps) {
		IToken x = Token.NoToken;
		IToken id;  BoundVar bv;
		var bvs = new List<BoundVar>();
		var reads = new List<FrameExpression>();
		Attributes readsAttrs = null;
		Expression req = null;
		Expression body = null;
		
		if (StartOf(9)) {
			WildIdent(out id, true);
			x = t; bvs.Add(new BoundVar(id, id.val, new InferredTypeProxy()) {RangeToken = new RangeToken(x, x)}); 
		} else if (la.kind == 88) {
			Get();
			x = t; 
			if (StartOf(9)) {
				IdentTypeOptional(out bv);
				bvs.Add(bv); 
				while (la.kind == 25) {
					Get();
					IdentTypeOptional(out bv);
					bvs.Add(bv); 
				}
			}
			Expect(89);
		} else SynErr(278);
		LambdaSpec(ref reads, ref readsAttrs, ref req);
		Expect(33);
		Expression(out body, allowLemma, true, allowBitwiseOps);
		e = new LambdaExpr(x, new RangeToken(x, t), bvs, req, new Specification<FrameExpression>(reads, readsAttrs), body);
		SystemModuleModifiers.Add(b => b.CreateArrowTypeDecl(bvs.Count));
		
	}

	void EndlessExpression(out Expression e, bool allowLemma, bool allowLambda, bool allowBitwiseOps) {
		Statement s;
		e = dummyExpr;
		
		switch (la.kind) {
		case 122: {
			IfExpression(out e, allowLemma, allowLambda, allowBitwiseOps);
			break;
		}
		case 125: {
			MatchExpression(out e, allowLemma, allowLambda, allowBitwiseOps);
			break;
		}
		case 127: case 137: {
			QuantifierExpression(out e, allowLemma, allowLambda);
			break;
		}
		case 16: case 17: {
			SetComprehensionExpr(out e, allowLemma, allowLambda, allowBitwiseOps);
			break;
		}
		case 34: case 35: case 36: case 99: case 100: {
			StmtInExpr(out s);
			Expression(out e, allowLemma, allowLambda, allowBitwiseOps);
			e = new StmtExpr(s.Tok, s, e) { RangeToken = new RangeToken(s.StartToken, e.EndToken) }; 
			break;
		}
		case 63: case 75: case 121: {
			LetExpression(out e, allowLemma, allowLambda, allowBitwiseOps);
			break;
		}
		case 20: case 21: {
			MapComprehensionExpr(out e, allowLemma, allowLambda, allowBitwiseOps);
			break;
		}
		default: SynErr(279); break;
		}
	}

	void NameSegment(out Expression e) {
		IToken id;
		IToken openParen = null; IToken atLabel = null;
		List<Type> typeArgs = null; List<ActualBinding> args = null;
		
		Ident(out id);
		if (IsGenericInstantiation(true)) {
			typeArgs = new List<Type>(); 
			GenericInstantiation(typeArgs);
			if (la.kind == 96) {
				AtCall(out atLabel, out openParen, out args);
			}
		} else if (la.kind == 129) {
			HashCall(id, out openParen, out typeArgs, out args);
		} else if (StartOf(46)) {
			if (la.kind == 96) {
				AtCall(out atLabel, out openParen, out args);
			}
		} else SynErr(280);
		e = new NameSegment(id, id.val, typeArgs);
		if (openParen != null) {
		 e = new ApplySuffix(openParen, atLabel, e, args, t);
		} else {
		 Contract.Assert(atLabel == null);
		}
		e.RangeToken = new RangeToken(id, t);
		
	}

	void SeqDisplayExpr(out Expression e) {
		Contract.Ensures(Contract.ValueAtReturn(out e) != null);
		IToken x = null;
		IToken startInstantiation = null;
		Type explicitTypeArg = null;
		Expression n, f;
		e = dummyExpr;
		
		if (la.kind == 19) {
			Get();
			x = t; 
			if (la.kind == 90) {
				var gt = new List<Type>(); startInstantiation = la; 
				GenericInstantiation(gt);
				if (gt.Count > 1) {
				 SemErr(ErrorId.p_seq_display_has_one_type_argument, new RangeToken(startInstantiation,t), "seq type expects only one type argument");
				} else {
				 explicitTypeArg = gt[0];
				}
				
			}
			Expect(88);
			Expression(out n, true, true);
			Expect(25);
			Expression(out f, true, true);
			Expect(89);
			e = new SeqConstructionExpr(x, explicitTypeArg, n, f); 
		} else if (la.kind == 86) {
			Get();
			List<Expression> elements = new List<Expression/*!*/>();
			x = t;
			
			
			if (StartOf(4)) {
				Expressions(elements);
			}
			e = new SeqDisplayExpr(x, elements);
			
			Expect(87);
		} else SynErr(281);
		e.RangeToken = new RangeToken(x, t); 
	}

	void ConstAtomExpression(out Expression e) {
		Contract.Ensures(Contract.ValueAtReturn(out e) != null);
		IToken/*!*/ x = null;
		e = dummyExpr;
		
		switch (la.kind) {
		case 2: case 3: case 4: case 22: case 23: case 45: case 147: case 148: case 149: {
			LiteralExpression(out e);
			break;
		}
		case 142: {
			Get();
			x = t; e = new ThisExpr(t); 
			break;
		}
		case 143: {
			Get();
			x = t; 
			Expect(88);
			Expression(out e, true, true);
			Expect(89);
			e = new UnaryOpExpr(x, UnaryOpExpr.Opcode.Allocated, e); 
			break;
		}
		case 144: {
			Get();
			x = t; IToken atLabel = null; 
			if (la.kind == 96) {
				Get();
				LabelName(out atLabel);
			}
			Expect(88);
			Expression(out e, true, true);
			Expect(89);
			e = new FreshExpr(x, e, atLabel?.val); 
			break;
		}
		case 145: {
			Get();
			x = t; FrameExpression fe; var mod = new List<FrameExpression>(); IToken atLabel = null; 
			if (la.kind == 96) {
				Get();
				LabelName(out atLabel);
			}
			Expect(88);
			FrameExpression(out fe, false, false);
			mod.Add(fe); 
			while (la.kind == 25) {
				Get();
				FrameExpression(out fe, false, false);
				mod.Add(fe); 
			}
			Expect(89);
			e = new UnchangedExpr(x, mod, atLabel?.val); 
			break;
		}
		case 146: {
			Get();
			x = t; IToken atLabel = null; 
			if (la.kind == 96) {
				Get();
				LabelName(out atLabel);
			}
			Expect(88);
			Expression(out e, true, true);
			Expect(89);
			e = new OldExpr(x, e, atLabel?.val); 
			break;
		}
		case 26: {
			Get();
			x = t; 
			Expression(out e, true, true, false);
			e = new UnaryOpExpr(x, UnaryOpExpr.Opcode.Cardinality, e); 
			Expect(26);
			break;
		}
		case 88: {
			ParensExpression(out e);
			break;
		}
		default: SynErr(282); break;
		}
		if(x!= null) { e.RangeToken = new RangeToken(x, t); } 
	}

	void LiteralExpression(out Expression e) {
		BigInteger n; BaseTypes.BigDec d;
		e = dummyExpr;
		
		switch (la.kind) {
		case 147: {
			Get();
			e = new LiteralExpr(t, false); 
			break;
		}
		case 148: {
			Get();
			e = new LiteralExpr(t, true); 
			break;
		}
		case 45: {
			Get();
			e = new HoleExpr(t, "??"); 
			break;
		}
		case 149: {
			Get();
			e = new LiteralExpr(t); 
			break;
		}
		case 2: case 3: {
			Nat(out n);
			e = new LiteralExpr(t, n); 
			break;
		}
		case 4: {
			Dec(out d);
			e = new LiteralExpr(t, d); 
			break;
		}
		case 22: {
			Get();
			string s = t.val.Substring(1, t.val.Length - 2);
			Util.ValidateEscaping(theOptions, t, s, false, errors);
			if (Util.UnescapedCharacters(theOptions, s, false).Count() > 1) {
			 errors.SemErr(ErrorId.p_invalid_char_literal, t, "too many characters in character literal");
			}
			e = new CharLiteralExpr(t, s); 
			break;
		}
		case 23: {
			Get();
			bool isVerbatimString;
			string s = Util.RemoveParsedStringQuotes(t.val, out isVerbatimString);
			Util.ValidateEscaping(theOptions, t, s, isVerbatimString, errors);
			e = new StringLiteralExpr(t, s, isVerbatimString);
			
			break;
		}
		default: SynErr(283); break;
		}
		e.RangeToken = new RangeToken(t, t); 
	}

	void ParensExpression(out Expression e) {
		IToken lp; IToken rp;
		var args = new List<ActualBinding>();
		
		Expect(88);
		lp = t; 
		if (StartOf(4)) {
			TupleArgs(args);
		}
		Expect(89);
		rp = t; 
		if (args.Count == 1 && !args[0].IsGhost) {
		 if (args[0].FormalParameterName != null) {
		   SemErr(ErrorId.p_no_parenthesized_binding, new RangeToken(lp,rp), "binding not allowed in parenthesized expression");
		 }
		 e = new ParensExpression(lp, args[0].Actual);
		} else {
		 // Compute the actual position of ghost arguments
		 var ghostness = new bool[args.Count];
		 for (var i = 0; i < args.Count; i++) {
		   ghostness[i] = false;
		 }
		 for (var i = 0; i < args.Count; i++) {
		   var arg = args[i];
		   if (arg.IsGhost) {
		     if (arg.FormalParameterName == null) {
		       ghostness[i] = true;
		     } else {
		       var success = int.TryParse(arg.FormalParameterName.val, out var index);
		       if (success && 0 <= index && index < args.Count) {
		         ghostness[index] = true;
		       }
		     }
		   }
		 }
		 var argumentGhostness = ghostness.ToList();
		 // make sure the corresponding tuple type exists
		 SystemModuleModifiers.Add(b => b.TupleType(lp, args.Count, true, argumentGhostness));
		 e = new DatatypeValue(lp, SystemModuleManager.TupleTypeName(argumentGhostness), SystemModuleManager.TupleTypeCtorName(args.Count), args);
		}
		
	}

	void Nat(out BigInteger n) {
		n = BigInteger.Zero;
		string S;
		
		if (la.kind == 2) {
			Get();
			S = Util.RemoveUnderscores(t.val);
			try {
			 n = BigIntegerParser.Parse(S);
			} catch (System.FormatException) {
			 SemErr(ErrorId.p_bad_number_format, t, "incorrectly formatted number");
			 n = BigInteger.Zero;
			}
			
		} else if (la.kind == 3) {
			Get();
			S = Util.RemoveUnderscores(t.val.Substring(2));
			try {
			 // note: leading 0 required when parsing positive hex numbers
			 n = BigIntegerParser.Parse("0" + S, System.Globalization.NumberStyles.HexNumber);
			} catch (System.FormatException) {
			 SemErr(ErrorId.p_bad_hex_number_format, t, "incorrectly formatted number");
			 n = BigInteger.Zero;
			}
			
		} else SynErr(284);
	}

	void Dec(out BaseTypes.BigDec d) {
		d = BaseTypes.BigDec.ZERO; 
		Expect(4);
		var S = Util.RemoveUnderscores(t.val);
		try {
		 d = BaseTypes.BigDec.FromString(S);
		} catch (System.FormatException) {
		 SemErr(ErrorId.p_bad_decimal_number_format, t, "incorrectly formatted number");
		 d = BaseTypes.BigDec.ZERO;
		}
		
	}

	void LambdaSpec(ref List<FrameExpression> reads, ref Attributes readsAttrs, ref Expression req) {
		while (la.kind == 72 || la.kind == 73) {
			if (la.kind == 72) {
				ReadsClause(reads, ref readsAttrs, true, false, true);
			} else {
				Get();
				Expression ee; 
				Expression(out ee, true, false);
				req = req == null ? ee : new BinaryExpr(req.tok, BinaryExpr.Opcode.And, req, ee) { RangeToken = new RangeToken(req.StartToken, ee.EndToken) } ; 
			}
		}
	}

	void TupleArgs(List<ActualBinding> args) {
		ActualBinding binding; bool isGhost = false; 
		if (la.kind == _ghost && !IsPeekVar()) {
			Expect(75);
			isGhost = true; 
		}
		ActualBinding(out binding, isGhost);
		args.Add(binding); 
		while (la.kind == 25) {
			Get();
			isGhost = false; 
			if (la.kind == _ghost && !IsPeekVar()) {
				Expect(75);
				isGhost = true; 
			}
			ActualBinding(out binding, isGhost);
			args.Add(binding); 
		}
	}

	void ActualBinding(out ActualBinding binding, bool isGhost = false) {
		IToken id = null; Expression e; 
		if (IsBinding()) {
			NoUSIdentOrDigits(out id);
			Expect(28);
		}
		Expression(out e, true, true);
		binding = new ActualBinding(id, e, isGhost); 
	}

	void MapLiteralExpressions(out List<ExpressionPair> elements) {
		Expression/*!*/ d, r;
		elements = new List<ExpressionPair/*!*/>();
		
		Expression(out d, true, true);
		Expect(28);
		Expression(out r, true, true);
		elements.Add(new ExpressionPair(d,r)); 
		while (la.kind == 25) {
			Get();
			Expression(out d, true, true);
			Expect(28);
			Expression(out r, true, true);
			elements.Add(new ExpressionPair(d,r)); 
		}
	}

	void MapComprehensionExpr(out Expression e, bool allowLemma, bool allowLambda, bool allowBitwiseOps) {
		Contract.Ensures(Contract.ValueAtReturn(out e) != null);
		List<BoundVar> bvars = new List<BoundVar>();
		Expression range = null;
		Expression bodyLeft = null;
		Expression bodyRight;
		Attributes attrs = null;
		bool finite = true;
		
		if (la.kind == 20) {
			Get();
		} else if (la.kind == 21) {
			Get();
			finite = false; 
		} else SynErr(285);
		IToken mapToken = t; 
		QuantifierDomain(out bvars, out attrs, out range, allowLemma, allowLambda, allowBitwiseOps);
		QSep();
		Expression(out bodyRight, allowLemma, allowLambda, allowBitwiseOps);
		if (IsGets()) {
			bodyLeft = bodyRight; 
			Expect(28);
			Expression(out bodyRight, allowLemma, allowLambda, allowBitwiseOps || !finite);
		}
		if (bodyLeft == null && bvars.Count != 1) {
		 SemErr(ErrorId.p_map_comprehension_must_have_term_expression, t, "a map comprehension with more than one bound variable must have a term expression of the form 'Expr := Expr'");
		 e = dummyExpr;
		} else {
		 e = new MapComprehension(mapToken, new RangeToken(mapToken, t), finite, bvars, range ?? new LiteralExpr(Token.NoToken, true), bodyLeft, bodyRight, attrs);
		}
		
	}

	void IfExpression(out Expression e, bool allowLemma, bool allowLambda, bool allowBitwiseOps) {
		Expect(122);
		IToken x = t; Expression e0; Expression e1;
		bool isBindingGuard = false;
		e = dummyExpr;
		
		if (IsBindingGuard()) {
			BindingGuard(out e, true);
			isBindingGuard = true; 
		} else if (StartOf(4)) {
			Expression(out e, true, true);
		} else SynErr(286);
		Expect(38);
		Expression(out e0, true, true, true);
		Expect(39);
		Expression(out e1, allowLemma, allowLambda, allowBitwiseOps);
		if (isBindingGuard) {
		 var exists = (ExistsExpr) e;
		 var LHSs = new List<CasePattern<BoundVar>>();
		 foreach (var v in exists.BoundVars) {
		   LHSs.Add(new CasePattern<BoundVar>(e.tok, v));
		 }
		 e0 = new LetExpr(e.tok, LHSs, new List<Expression>() {
		   exists.Term }, e0, false) { RangeToken = exists.RangeToken};
		}
		e = new ITEExpr(x, isBindingGuard, e, e0, e1);
		e.RangeToken = new RangeToken(x, t);
		
	}

	void MatchExpression(out Expression e, bool allowLemma, bool allowLambda, bool allowBitwiseOps) {
		Contract.Ensures(Contract.ValueAtReturn(out e) != null); IToken/*!*/ x;  NestedMatchCaseExpr/*!*/ c;
		List<NestedMatchCaseExpr/*!*/> cases = new List<NestedMatchCaseExpr/*!*/>();
		bool usesOptionalBraces = false;
		
		Expect(125);
		x = t; 
		Expression(out e, allowLemma, allowLambda, allowBitwiseOps);
		if (la.kind == _lbrace) {
			Expect(84);
			usesOptionalBraces = true; 
			while (la.kind == 37) {
				CaseExpression(out c, true, true, allowBitwiseOps);
				cases.Add(c); 
			}
			Expect(85);
		} else if (StartOf(47)) {
			while (la.kind == _case) {
				CaseExpression(out c, allowLemma, allowLambda, allowBitwiseOps);
				cases.Add(c); 
			}
		} else SynErr(287);
		e = new NestedMatchExpr(x, e, cases, usesOptionalBraces);
		e.RangeToken = new RangeToken(x, t); 
	}

	void QuantifierExpression(out Expression q, bool allowLemma, bool allowLambda) {
		Contract.Ensures(Contract.ValueAtReturn(out q) != null);
		IToken/*!*/ x = Token.NoToken;
		bool univ = false;
		List<BoundVar/*!*/> bvars;
		Attributes attrs;
		Expression range;
		Expression/*!*/ body;
		
		if (la.kind == 127) {
			Forall();
			x = t;  univ = true; 
		} else if (la.kind == 137) {
			Exists();
			x = t; 
		} else SynErr(288);
		QuantifierDomain(out bvars, out attrs, out range, allowLemma, allowLambda, true);
		QSep();
		Expression(out body, allowLemma, allowLambda);
		if (univ) {
		 q = new ForallExpr(x, new RangeToken(x, t), bvars, range, body, attrs);
		} else {
		 q = new ExistsExpr(x, new RangeToken(x, t), bvars, range, body, attrs);
		}
		
	}

	void SetComprehensionExpr(out Expression q, bool allowLemma, bool allowLambda, bool allowBitwiseOps) {
		Contract.Ensures(Contract.ValueAtReturn(out q) != null);
		List<BoundVar/*!*/> bvars = new List<BoundVar>();
		Expression range;
		Expression body = null;
		Attributes attrs = null;
		bool finite = true;
		
		if (la.kind == 16) {
			Get();
		} else if (la.kind == 17) {
			Get();
			finite = false; 
		} else SynErr(289);
		IToken setToken = t; 
		QuantifierDomain(out bvars, out attrs, out range, allowLemma, allowLambda, allowBitwiseOps);
		if (IsQSep()) {
			QSep();
			Expression(out body, allowLemma, allowLambda, allowBitwiseOps || !finite);
		}
		if (body == null && bvars.Count != 1) {
		 SemErr(ErrorId.p_set_comprehension_needs_term_expression, t, "a set comprehension with more than one bound variable must have a term expression");
		 q = dummyExpr;
		} else {
		 // This production used to have its own version of QuantifierDomain in which the
		 // range was not optional, so we map null to "true" here so that the rest of the
		 // logic doesn't hit exceptions.
		 if (range == null) {
		   range = LiteralExpr.CreateBoolLiteral(new AutoGeneratedToken(t), true);
		 }
		 q = new SetComprehension(setToken, new RangeToken(setToken, t), finite, bvars, range, body, attrs);
		}
		
	}

	void StmtInExpr(out Statement s) {
		s = dummyStmt; 
		if (la.kind == 35) {
			AssertStmt(out s);
		} else if (la.kind == 100) {
			ExpectStmt(out s);
		} else if (la.kind == 34) {
			AssumeStmt(out s);
		} else if (la.kind == 99) {
			RevealStmt(out s);
		} else if (la.kind == 36) {
			CalcStmt(out s);
		} else SynErr(290);
	}

	void LetExpression(out Expression e, bool allowLemma, bool allowLambda, bool allowBitwiseOps) {
		e = dummyExpr; 
		if (la.kind == 63 || la.kind == 75) {
			LetExprWithLHS(out e, allowLemma, allowLambda, allowBitwiseOps);
		} else if (la.kind == 121) {
			LetExprWithoutLHS(out e, allowLemma, allowLambda, allowBitwiseOps);
		} else SynErr(291);
	}

	void LetExprWithLHS(out Expression e, bool allowLemma, bool allowLambda, bool allowBitwiseOps) {
		IToken x = null;
		bool isGhost = false;
		var letLHSs = new List<CasePattern<BoundVar>>();
		var letRHSs = new List<Expression>();
		IToken lastLHS = null;
		IToken lastRHS = null;
		CasePattern<BoundVar> pat;
		bool exact = true;
		bool isLetOrFail = false;
		Attributes attrs = null;
		e = dummyExpr;
		
		if (la.kind == 75) {
			Get();
			isGhost = true;  x = t; 
		}
		Expect(63);
		if (!isGhost) { x = t; } 
		CasePattern(out pat);
		if (isGhost) { pat.Vars.ForEach(bv => bv.IsGhost = true); }
		letLHSs.Add(pat);
		lastLHS = la;
		
		while (la.kind == 25) {
			Get();
			CasePattern(out pat);
			if (isGhost) { pat.Vars.ForEach(bv => bv.IsGhost = true); }
			letLHSs.Add(pat);
			
		}
		if (la.kind == 28) {
			Get();
		} else if (la.kind == 29 || la.kind == 83) {
			while (la.kind == 83) {
				Attribute(ref attrs);
			}
			Expect(29);
			exact = false;
			foreach (var lhs in letLHSs) {
			 if (lhs.Arguments != null) {
			   SemErr(ErrorId.p_no_patterns_in_let_such_that, lhs.tok, "LHS of let-such-that expression must be variables, not general patterns");
			 }
			}
			
		} else if (la.kind == 121) {
			Get();
			isLetOrFail = true; 
		} else if (la.kind == 92) {
			Get();
			SemErr(ErrorId.p_no_equal_in_let_initialization, t, "a variable in a let expression should be initialized using ':=', ':-', or ':|', not '='"); 
		} else SynErr(292);
		Expression(out e, false, true);
		letRHSs.Add(e); lastRHS = la; 
		while (la.kind == 25) {
			Get();
			Expression(out e, false, true);
			letRHSs.Add(e); 
		}
		Expect(32);
		Expression(out e, allowLemma, allowLambda, allowBitwiseOps);
		if (isLetOrFail) {
		 CasePattern<BoundVar> lhs = null;
		 Contract.Assert(letLHSs.Count > 0);
		 if (letLHSs.Count == 1) {
		   lhs = letLHSs[0];
		 } else {
		   var erange = new RangeToken(letLHSs[1].StartToken.Prev, letLHSs[^1].EndToken);
		   SemErr(ErrorId.p_elephant_has_one_lhs, erange, "':-' can have at most one left-hand side");
		 }
		 Expression rhs = null;
		 Contract.Assert(letRHSs.Count > 0);
		 if (letRHSs.Count == 1) {
		   rhs = letRHSs[0];
		 } else {
		   var erange = new RangeToken(letRHSs[0].EndToken.Next, letRHSs[^1].EndToken);
		   SemErr(ErrorId.p_elephant_has_one_rhs, erange, "':-' must have exactly one right-hand side");
		 }
		 e = new LetOrFailExpr(x, lhs, rhs, e);
		} else {
		 e = new LetExpr(x, letLHSs, letRHSs, e, exact, attrs);
		}
		e.RangeToken = new RangeToken(x, t);
		
	}

	void LetExprWithoutLHS(out Expression e, bool allowLemma, bool allowLambda, bool allowBitwiseOps) {
		IToken x;
		Expression rhs;
		Expression body;
		
		Expect(121);
		x = t; 
		Expression(out rhs, false, true);
		Expect(32);
		Expression(out body, allowLemma, allowLambda, allowBitwiseOps);
		e = new LetOrFailExpr(x, null, rhs, body);
		e.RangeToken = new RangeToken(x, t);
		
	}

	void CasePattern(out CasePattern<BoundVar> pat) {
		IToken id;  List<CasePattern<BoundVar>> arguments;
		BoundVar bv;
		pat = null;
		
		if (IsIdentParen()) {
			Ident(out id);
			Expect(88);
			arguments = new List<CasePattern<BoundVar>>(); 
			if (StartOf(31)) {
				CasePattern(out pat);
				arguments.Add(pat); 
				while (la.kind == 25) {
					Get();
					CasePattern(out pat);
					arguments.Add(pat); 
				}
			}
			Expect(89);
			pat = new CasePattern<BoundVar>(id, id.val, arguments); 
		} else if (la.kind == 88) {
			Get();
			id = t;
			arguments = new List<CasePattern<BoundVar>>();
			
			if (StartOf(31)) {
				CasePattern(out pat);
				arguments.Add(pat); 
				while (la.kind == 25) {
					Get();
					CasePattern(out pat);
					arguments.Add(pat); 
				}
			}
			Expect(89);
			string ctor = SystemModuleManager.TupleTypeCtorName(arguments.Count);  //use the TupleTypeCtors
			pat = new CasePattern<BoundVar>(id, ctor, arguments);
			
		} else if (StartOf(9)) {
			IdentTypeOptional(out bv);
			pat = new CasePattern<BoundVar>(bv.tok, bv);
			
		} else SynErr(293);
		if (pat == null) {
		 pat = new CasePattern<BoundVar>(t, "_ParseError", null);
		}
		
	}

	void CaseExpression(out NestedMatchCaseExpr c, bool allowLemma, bool allowLambda, bool allowBitwiseOps) {
		Contract.Ensures(Contract.ValueAtReturn(out c) != null); IToken/*!*/ x;
		ExtendedPattern/*!*/ pat = null;
		Expression/*!*/ body;
		Attributes attrs = null;
		
		Expect(37);
		x = t; 
		while (la.kind == 83) {
			Attribute(ref attrs);
		}
		ExtendedPattern(out pat);
		
		Expect(33);
		Expression(out body, allowLemma, allowLambda, allowBitwiseOps);
		c = new NestedMatchCaseExpr(x, pat, body, attrs); 
	}

	void AtCall(out IToken atLabel, out IToken openParen, out List<ActualBinding> args) {
		atLabel = null;
		openParen = null;
		args = new List<ActualBinding>();
		
		Expect(96);
		LabelName(out atLabel);
		Expect(88);
		openParen = t; 
		if (StartOf(4)) {
			ActualBindings(args);
		}
		Expect(89);
	}

	void HashCall(IToken id, out IToken openParen, out List<Type> typeArgs, out List<ActualBinding> args) {
		Expression k; args = new List<ActualBinding>(); typeArgs = null; 
		Expect(129);
		id.val = id.val + "#"; t.val = ""; t.pos = t.pos+1; t.col = t.col+1; 
		if (la.kind == 90) {
			typeArgs = new List<Type>(); 
			GenericInstantiation(typeArgs);
		}
		Expect(86);
		Expression(out k, true, true);
		Expect(87);
		args.Add(new ActualBinding(null, k)); 
		Expect(88);
		openParen = t; 
		if (StartOf(4)) {
			ActualBindings(args);
		}
		Expect(89);
	}

	void MemberBindingUpdate(out IToken id, out Expression e) {
		id = Token.NoToken; e = dummyExpr; 
		NoUSIdentOrDigits(out id);
		Expect(28);
		Expression(out e, true, true);
	}

	void DotSuffix(out IToken x, out IToken y) {
		Contract.Ensures(Contract.ValueAtReturn(out x) != null);
		x = Token.NoToken;
		y = null;
		
		if (StartOf(9)) {
			Ident(out x);
		} else if (la.kind == 2) {
			Get();
			x = t; 
		} else if (la.kind == 4) {
			Get();
			x = t;
			int exponent = x.val.IndexOf('e');
			if (0 <= exponent) {
			 // this is not a legal field/destructor name
			 // Also it is not currently reachable, because decimaldigits does not yet support exponents
			 SemErr(ErrorId.p_invalid_name_after_dot, x, "invalid name after a '.'");
			} else {
			 int dot = x.val.IndexOf('.');
			 if (0 <= dot) {
			   // change token
			   // [prev][    x    ]
			   // to
			   // [prev][y][dot][x]
			   y = new Token();
			   y.pos = x.pos;
			   y.val = x.val.Substring(0, dot);
			   y.col = x.col;
			   y.line = x.line;
			   y.Uri = x.Uri;
			   y.kind = x.kind;
			   
			   var dotTok = new Token();
			   dotTok.pos = x.pos + dot;
			   dotTok.val = ".";
			   dotTok.Uri = x.Uri;
			   dotTok.line = x.line;
			   dotTok.kind = x.kind;
			   dotTok.col = x.col + dot;
			   
			   x.pos = x.pos + dot + 1;
			   x.val = x.val.Substring(dot + 1);
			   x.col = x.col + dot + 1;
			   
			   var prev = x.Prev;
			   
			   prev.Next = y;
			   y.Prev = prev;
			   
			   y.Next = dotTok;
			   dotTok.Prev = y;
			   
			   dotTok.Next = x;
			   x.Prev = dotTok;
			   
			   // Ok, now swaps x and y when returning
			   var tmp = x;
			   x = y;
			   y = tmp;
			 }
			}
			
		} else if (la.kind == 73) {
			Get();
			x = t; 
		} else if (la.kind == 72) {
			Get();
			x = t; 
		} else SynErr(294);
	}

	void QuantifierVariableDecl(out QuantifiedVar qvar, ref Attributes attrs, bool allowLemma, bool allowLambda, bool allowBitwiseOps) {
		BoundVar bv;
		Expression domain = null;
		Expression range = null;
		
		IdentTypeOptional(out bv);
		if (IsFromArrow()) {
			Expect(90);
			Expect(104);
			Expression(out domain, allowLemma, allowLambda, false);
		}
		while (la.kind == _lbracecolon) {
			Attribute(ref attrs);
		}
		if (la.kind == _verticalbar) {
			Expect(26);
			Expression(out range, allowLemma, allowLambda, allowBitwiseOps);
		}
		qvar = new QuantifiedVar(bv.tok, bv.Name, bv.SyntacticType, domain, range); 
	}

	void AttributeName(out IToken id) {
		NoUSIdent(out id);
	}



  public void Parse() {
    la = scanner.FirstToken;
    Get();
		Dafny();
		Expect(0);

  }

  static readonly bool[,] set = {
		{_T,_T,_T,_T, _T,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_T,_T, _x,_x,_T,_x, _x,_x,_x,_x, _T,_x,_T,_T, _T,_T,_x,_x, _x,_x,_x,_x, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _x,_x,_x,_T, _x,_T,_x,_x, _T,_T,_x,_x, _T,_x,_x,_x, _x,_x,_x,_x, _x,_x,_T,_T, _T,_x,_x,_x, _x,_x,_T,_T, _T,_x,_x,_x, _x,_x,_x,_x, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_T,_T, _T,_T,_T,_T, _T,_T,_x,_x, _x},
		{_x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_x, _x,_x,_x,_T, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_T,_T, _T,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x},
		{_x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_T, _x,_x,_x,_x, _T,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_T, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_T,_T, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x},
		{_x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_x,_x,_x, _x,_x,_x,_T, _T,_x,_x,_x, _T,_T,_T,_x, _x,_x,_x,_T, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_T,_T, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x},
		{_x,_T,_T,_T, _T,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _T,_T,_T,_T, _T,_T,_T,_T, _x,_x,_T,_x, _x,_x,_x,_x, _x,_x,_T,_T, _T,_x,_x,_x, _x,_x,_x,_x, _x,_T,_x,_x, _x,_T,_T,_T, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_T, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_T, _x,_x,_x,_T, _x,_T,_x,_x, _T,_x,_T,_x, _T,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_T, _T,_x,_x,_x, _T,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_T, _x,_x,_x,_x, _x,_T,_T,_x, _x,_T,_x,_T, _x,_x,_x,_x, _x,_x,_x,_T, _T,_T,_x,_x, _x,_x,_T,_T, _T,_T,_T,_T, _T,_T,_x,_x, _x},
		{_x,_T,_x,_x, _x,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_T,_T,_T, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_T,_x,_x, _x,_x,_x,_x, _T,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x},
		{_x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_T,_x, _x,_x,_x,_x, _T,_x,_x,_x, _x,_x,_x,_x, _T,_x,_x,_x, _x,_x,_T,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x},
		{_x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_T,_T,_x, _T,_T,_x,_T, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _T,_T,_T,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x},
		{_x,_T,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_T,_T,_T, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_T,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_T,_T,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x},
		{_x,_T,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_T,_T,_T, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_T,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x},
		{_x,_T,_T,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_T,_T,_T, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_T,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x},
		{_x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_T, _x,_x,_x,_x, _x,_x,_x,_x, _T,_x,_x,_x, _x,_x,_x,_x, _x,_x,_T,_T, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x},
		{_T,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_T,_T,_x, _T,_T,_x,_T, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _T,_T,_T,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x},
		{_x,_T,_T,_x, _x,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_T,_T,_T, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_T, _x,_x,_x,_x, _T,_T,_x,_T, _x,_x,_x,_x, _T,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x},
		{_T,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_T,_x,_x, _T,_x,_x,_x, _T,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_x, _x,_x,_x,_T, _x,_x,_x,_x, _x,_x,_x,_x, _x,_T,_x,_x, _x,_x,_x,_x, _T,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_T,_T, _T,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x},
		{_x,_T,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_T,_T,_T, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_T, _x,_x,_x,_T, _T,_T,_x,_T, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x},
		{_T,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _T,_x,_x,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _x,_x,_x,_x, _x,_x,_x,_x, _T,_T,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_T,_T, _T,_x,_x,_x, _x,_x,_x,_x, _T,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x},
		{_x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _T,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_T, _T,_T,_T,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _T,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x},
		{_x,_T,_T,_T, _T,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_T,_T, _x,_x,_T,_x, _x,_x,_x,_x, _x,_x,_T,_T, _T,_x,_x,_x, _x,_x,_x,_x, _x,_T,_x,_x, _x,_T,_T,_T, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_T, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_T, _x,_x,_x,_x, _x,_T,_x,_x, _T,_x,_x,_x, _T,_x,_x,_x, _x,_x,_x,_x, _x,_x,_T,_T, _T,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_T,_T, _T,_T,_T,_T, _T,_T,_x,_x, _x},
		{_x,_T,_x,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_x,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_x, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _x},
		{_T,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _T,_x,_x,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _x,_x,_x,_x, _x,_x,_x,_x, _T,_T,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_T,_T, _T,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x},
		{_x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _T,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_T, _T,_T,_T,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x},
		{_x,_T,_T,_T, _T,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _T,_T,_T,_T, _T,_T,_T,_T, _x,_x,_T,_x, _x,_x,_x,_T, _x,_x,_T,_T, _T,_x,_x,_x, _x,_x,_x,_x, _x,_T,_x,_x, _x,_T,_T,_T, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_T, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_T, _x,_x,_x,_T, _x,_T,_x,_x, _T,_x,_T,_x, _T,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_T, _T,_x,_x,_x, _T,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_T, _x,_x,_x,_x, _x,_T,_T,_x, _x,_T,_x,_T, _x,_x,_x,_x, _x,_x,_x,_T, _T,_T,_x,_x, _x,_x,_T,_T, _T,_T,_T,_T, _T,_T,_x,_x, _x},
		{_x,_T,_x,_x, _x,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_T,_T,_T, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_T, _x,_x,_x,_x, _x,_T,_x,_x, _x,_x,_x,_x, _T,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x},
		{_T,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _T,_x,_x,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_x, _T,_T,_T,_T, _x,_x,_x,_x, _x,_x,_x,_x, _T,_T,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_T,_T, _T,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x},
		{_x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _T,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _T,_T,_T,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x},
		{_T,_T,_T,_T, _T,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_T,_T, _x,_x,_T,_x, _x,_x,_x,_x, _x,_x,_T,_T, _T,_x,_x,_x, _x,_x,_x,_x, _x,_T,_x,_x, _x,_T,_T,_T, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_T, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_T, _x,_x,_x,_x, _x,_T,_x,_x, _T,_x,_x,_x, _T,_x,_x,_x, _x,_x,_x,_x, _x,_x,_T,_T, _T,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_T,_T, _T,_T,_T,_T, _T,_T,_x,_x, _x},
		{_x,_T,_T,_T, _T,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_T,_T, _x,_x,_T,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_T,_x,_x, _x,_T,_T,_T, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_T,_x,_x, _x,_x,_x,_x, _T,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_T,_T, _T,_T,_T,_T, _T,_T,_x,_x, _x},
		{_x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_T,_x,_x, _T,_T,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_T,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x},
		{_x,_T,_T,_T, _T,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_T,_T, _x,_x,_T,_x, _x,_x,_x,_x, _x,_x,_T,_T, _T,_T,_x,_x, _x,_x,_x,_x, _x,_T,_x,_x, _x,_T,_T,_T, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_T, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_T, _x,_x,_x,_T, _x,_T,_x,_T, _T,_T,_x,_x, _T,_x,_x,_x, _x,_x,_x,_x, _x,_x,_T,_T, _T,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_T,_T, _T,_T,_T,_T, _T,_T,_x,_x, _x},
		{_x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _T,_T,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_T, _x,_x,_x,_x, _x,_x,_x,_x, _T,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_T,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x},
		{_x,_T,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_T,_T,_T, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_T,_x,_x, _x,_x,_x,_x, _T,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x},
		{_x,_T,_T,_T, _T,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _T,_T,_T,_T, _T,_T,_T,_T, _x,_x,_T,_x, _x,_x,_x,_x, _x,_x,_T,_T, _T,_x,_x,_x, _x,_x,_x,_x, _x,_T,_x,_x, _x,_T,_T,_T, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_T, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_T, _x,_x,_x,_T, _x,_T,_x,_x, _T,_x,_T,_x, _T,_x,_x,_x, _x,_x,_x,_T, _x,_x,_x,_T, _T,_x,_x,_x, _T,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_T, _x,_x,_x,_x, _x,_T,_T,_x, _x,_T,_x,_T, _x,_x,_x,_x, _x,_x,_x,_T, _T,_T,_x,_x, _x,_x,_T,_T, _T,_T,_T,_T, _T,_T,_x,_x, _x},
		{_x,_T,_T,_T, _T,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _T,_T,_T,_T, _T,_T,_T,_T, _x,_x,_T,_x, _x,_x,_x,_x, _x,_x,_T,_T, _T,_x,_x,_x, _x,_x,_x,_x, _x,_T,_x,_x, _x,_T,_T,_T, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_T, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_T, _x,_x,_x,_T, _x,_T,_x,_x, _T,_x,_T,_x, _T,_x,_x,_x, _x,_x,_x,_T, _x,_x,_T,_T, _T,_x,_x,_x, _T,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_T, _x,_x,_x,_x, _x,_T,_T,_x, _x,_T,_x,_T, _x,_x,_x,_x, _x,_x,_x,_T, _T,_T,_x,_x, _x,_x,_T,_T, _T,_T,_T,_T, _T,_T,_x,_x, _x},
		{_x,_T,_T,_T, _T,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_T,_T, _x,_x,_T,_x, _x,_x,_x,_x, _x,_x,_T,_T, _T,_T,_x,_x, _x,_x,_x,_x, _x,_T,_x,_x, _x,_T,_T,_T, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_T, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_T, _x,_x,_x,_T, _x,_T,_x,_x, _T,_T,_x,_x, _T,_x,_x,_x, _x,_x,_x,_x, _x,_x,_T,_T, _T,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_T,_T, _T,_T,_T,_T, _T,_T,_x,_x, _x},
		{_x,_T,_T,_T, _T,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _T,_T,_T,_T, _T,_T,_T,_T, _x,_x,_T,_x, _x,_x,_x,_x, _x,_x,_T,_T, _T,_T,_x,_x, _x,_x,_x,_x, _x,_T,_x,_x, _x,_T,_T,_T, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_T, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_T, _x,_x,_x,_T, _x,_T,_x,_x, _T,_T,_T,_x, _T,_x,_x,_x, _x,_x,_x,_x, _x,_x,_T,_T, _T,_x,_x,_x, _T,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_x,_x,_x, _x,_x,_x,_T, _T,_T,_x,_x, _x,_x,_T,_T, _T,_T,_T,_T, _T,_T,_x,_x, _x},
		{_x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_T,_T, _x,_T,_T,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_T,_T, _T,_T,_T,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x},
		{_x,_T,_T,_T, _T,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_T,_T, _x,_x,_T,_x, _x,_x,_x,_x, _x,_x,_T,_T, _T,_T,_x,_x, _x,_x,_x,_x, _x,_T,_x,_x, _x,_T,_T,_T, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_T, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_T,_T, _x,_x,_x,_T, _x,_T,_x,_x, _T,_T,_x,_x, _T,_x,_x,_x, _x,_x,_x,_x, _x,_x,_T,_T, _T,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_T,_T, _T,_T,_T,_T, _T,_T,_x,_x, _x},
		{_x,_x,_T,_T, _T,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_T,_T, _x,_x,_T,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_T,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _T,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_T,_T, _T,_T,_T,_T, _T,_T,_x,_x, _x},
		{_T,_T,_T,_T, _T,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_T,_T, _x,_x,_T,_x, _x,_x,_x,_x, _x,_x,_T,_T, _T,_T,_x,_x, _x,_x,_x,_x, _x,_T,_x,_x, _x,_T,_T,_T, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_T, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_T, _x,_x,_x,_T, _x,_T,_x,_x, _T,_T,_x,_x, _T,_x,_x,_x, _x,_x,_x,_x, _x,_x,_T,_T, _T,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_T,_T, _T,_T,_T,_T, _T,_T,_x,_x, _x},
		{_x,_T,_T,_T, _T,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_T,_T, _x,_x,_T,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_T,_x,_x, _x,_T,_T,_T, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_T,_x,_x, _x,_x,_x,_x, _T,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _T,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_T, _T,_T,_x,_x, _x},
		{_x,_x,_T,_T, _T,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_T,_T, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_T,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _T,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_T, _T,_T,_x,_x, _x},
		{_x,_x,_T,_T, _T,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_T,_T, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_T,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_T, _T,_T,_x,_x, _x},
		{_x,_T,_T,_T, _T,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _T,_T,_T,_T, _T,_T,_T,_T, _x,_x,_T,_x, _x,_x,_x,_x, _x,_x,_T,_T, _T,_x,_x,_x, _x,_x,_x,_x, _x,_T,_x,_x, _x,_T,_T,_T, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_T, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_T, _x,_x,_x,_x, _x,_T,_x,_x, _T,_x,_T,_x, _T,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_T, _T,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_T,_T,_x, _x,_T,_x,_T, _x,_x,_x,_x, _x,_x,_x,_x, _x,_T,_x,_x, _x,_x,_T,_T, _T,_T,_T,_T, _T,_T,_x,_x, _x},
		{_x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _T,_T,_x,_x, _T,_T,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_T,_T, _T,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_T, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_T, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_T, _T,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_T,_T,_x, _x,_T,_x,_T, _x,_x,_x,_x, _x,_x,_x,_x, _x,_T,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x},
		{_x,_T,_T,_x, _T,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_T,_T,_T, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _T,_T,_x,_x, _x,_x,_x,_x, _x,_T,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x},
		{_T,_T,_T,_T, _T,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _x,_x,_x,_T, _x,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _x,_T,_T,_T, _T,_T,_T,_T, _T,_x,_x,_x, _T,_x,_T,_T, _T,_x,_x,_x, _x,_x,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_x,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_x, _x},
		{_T,_T,_T,_T, _T,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_x,_x,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _x,_x,_x,_T, _x,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _x,_T,_T,_T, _x,_T,_T,_T, _T,_x,_x,_x, _T,_x,_T,_T, _T,_x,_x,_x, _x,_x,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_x,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_x, _x}

  };
} // end Parser


public class Errors {
  public readonly ErrorReporter Reporting;
  public int ErrorCount;

  public Errors(ErrorReporter Reporting) {
    Contract.Requires(Reporting != null);
    this.Reporting = Reporting;
  }

  public void SynErr(Uri uri, int line, int col, int n) {
    SynErr(uri, line, col, GetSyntaxErrorString(n));
  }

  public void SynErr(Uri uri, int line, int col, string msg) {
    Contract.Requires(msg != null);
    ErrorCount++;
    Reporting.Error(MessageSource.Parser, ErrorId.p_generic_syntax_error, uri, line, col, msg);
  }

  string GetSyntaxErrorString(int n) {
    string s;
    switch (n) {
			case 0: s = "EOF expected"; break;
			case 1: s = "ident expected"; break;
			case 2: s = "digits expected"; break;
			case 3: s = "hexdigits expected"; break;
			case 4: s = "decimaldigits expected"; break;
			case 5: s = "arrayToken expected"; break;
			case 6: s = "bvToken expected"; break;
			case 7: s = "bool expected"; break;
			case 8: s = "char expected"; break;
			case 9: s = "int expected"; break;
			case 10: s = "nat expected"; break;
			case 11: s = "real expected"; break;
			case 12: s = "ORDINAL expected"; break;
			case 13: s = "object expected"; break;
			case 14: s = "object_q expected"; break;
			case 15: s = "string expected"; break;
			case 16: s = "set expected"; break;
			case 17: s = "iset expected"; break;
			case 18: s = "multiset expected"; break;
			case 19: s = "seq expected"; break;
			case 20: s = "map expected"; break;
			case 21: s = "imap expected"; break;
			case 22: s = "charToken expected"; break;
			case 23: s = "stringToken expected"; break;
			case 24: s = "colon expected"; break;
			case 25: s = "comma expected"; break;
			case 26: s = "verticalbar expected"; break;
			case 27: s = "doublecolon expected"; break;
			case 28: s = "gets expected"; break;
			case 29: s = "boredSmiley expected"; break;
			case 30: s = "dot expected"; break;
			case 31: s = "backtick expected"; break;
			case 32: s = "semicolon expected"; break;
			case 33: s = "darrow expected"; break;
			case 34: s = "assume expected"; break;
			case 35: s = "assert expected"; break;
			case 36: s = "calc expected"; break;
			case 37: s = "case expected"; break;
			case 38: s = "then expected"; break;
			case 39: s = "else expected"; break;
			case 40: s = "as expected"; break;
			case 41: s = "is expected"; break;
			case 42: s = "by expected"; break;
			case 43: s = "in expected"; break;
			case 44: s = "decreases expected"; break;
			case 45: s = "hole expected"; break;
			case 46: s = "invariant expected"; break;
			case 47: s = "function expected"; break;
			case 48: s = "predicate expected"; break;
			case 49: s = "least expected"; break;
			case 50: s = "greatest expected"; break;
			case 51: s = "opaque expected"; break;
			case 52: s = "inductive expected"; break;
			case 53: s = "twostate expected"; break;
			case 54: s = "copredicate expected"; break;
			case 55: s = "lemma expected"; break;
			case 56: s = "static expected"; break;
			case 57: s = "import expected"; break;
			case 58: s = "export expected"; break;
			case 59: s = "class expected"; break;
			case 60: s = "trait expected"; break;
			case 61: s = "datatype expected"; break;
			case 62: s = "codatatype expected"; break;
			case 63: s = "var expected"; break;
			case 64: s = "const expected"; break;
			case 65: s = "newtype expected"; break;
			case 66: s = "type expected"; break;
			case 67: s = "iterator expected"; break;
			case 68: s = "method expected"; break;
			case 69: s = "colemma expected"; break;
			case 70: s = "constructor expected"; break;
			case 71: s = "modifies expected"; break;
			case 72: s = "reads expected"; break;
			case 73: s = "requires expected"; break;
			case 74: s = "ensures expected"; break;
			case 75: s = "ghost expected"; break;
			case 76: s = "provides expected"; break;
			case 77: s = "reveals expected"; break;
			case 78: s = "extends expected"; break;
			case 79: s = "new expected"; break;
			case 80: s = "nameonly expected"; break;
			case 81: s = "older expected"; break;
			case 82: s = "witness expected"; break;
			case 83: s = "lbracecolon expected"; break;
			case 84: s = "lbrace expected"; break;
			case 85: s = "rbrace expected"; break;
			case 86: s = "lbracket expected"; break;
			case 87: s = "rbracket expected"; break;
			case 88: s = "openparen expected"; break;
			case 89: s = "closeparen expected"; break;
			case 90: s = "openAngleBracket expected"; break;
			case 91: s = "closeAngleBracket expected"; break;
			case 92: s = "singleeq expected"; break;
			case 93: s = "eq expected"; break;
			case 94: s = "neq expected"; break;
			case 95: s = "star expected"; break;
			case 96: s = "at expected"; break;
			case 97: s = "notIn expected"; break;
			case 98: s = "ellipsis expected"; break;
			case 99: s = "reveal expected"; break;
			case 100: s = "expect expected"; break;
			case 101: s = "sarrow expected"; break;
			case 102: s = "qarrow expected"; break;
			case 103: s = "larrow expected"; break;
			case 104: s = "minus expected"; break;
			case 105: s = "\"include\" expected"; break;
			case 106: s = "\"abstract\" expected"; break;
			case 107: s = "\"replaceable\" expected"; break;
			case 108: s = "\"module\" expected"; break;
			case 109: s = "\"refines\" expected"; break;
			case 110: s = "\"replaces\" expected"; break;
			case 111: s = "\"opened\" expected"; break;
			case 112: s = "\"yields\" expected"; break;
			case 113: s = "\"returns\" expected"; break;
			case 114: s = "\"+\" expected"; break;
			case 115: s = "\"!\" expected"; break;
			case 116: s = "\"yield\" expected"; break;
			case 117: s = "\"label\" expected"; break;
			case 118: s = "\"continue\" expected"; break;
			case 119: s = "\"break\" expected"; break;
			case 120: s = "\"return\" expected"; break;
			case 121: s = "\":-\" expected"; break;
			case 122: s = "\"if\" expected"; break;
			case 123: s = "\"while\" expected"; break;
			case 124: s = "\"for\" expected"; break;
			case 125: s = "\"match\" expected"; break;
			case 126: s = "\"print\" expected"; break;
			case 127: s = "\"forall\" expected"; break;
			case 128: s = "\"modify\" expected"; break;
			case 129: s = "\"#\" expected"; break;
			case 130: s = "\"<=\" expected"; break;
			case 131: s = "\">=\" expected"; break;
			case 132: s = "\"<==>\" expected"; break;
			case 133: s = "\"==>\" expected"; break;
			case 134: s = "\"<==\" expected"; break;
			case 135: s = "\"&&\" expected"; break;
			case 136: s = "\"||\" expected"; break;
			case 137: s = "\"exists\" expected"; break;
			case 138: s = "\"/\" expected"; break;
			case 139: s = "\"%\" expected"; break;
			case 140: s = "\"&\" expected"; break;
			case 141: s = "\"^\" expected"; break;
			case 142: s = "\"this\" expected"; break;
			case 143: s = "\"allocated\" expected"; break;
			case 144: s = "\"fresh\" expected"; break;
			case 145: s = "\"unchanged\" expected"; break;
			case 146: s = "\"old\" expected"; break;
			case 147: s = "\"false\" expected"; break;
			case 148: s = "\"true\" expected"; break;
			case 149: s = "\"null\" expected"; break;
			case 150: s = "\"..\" expected"; break;
			case 151: s = "??? expected"; break;
			case 152: s = "this symbol not expected in Dafny"; break;
			case 153: s = "invalid TopDecl"; break;
			case 154: s = "invalid DeclModifier"; break;
			case 155: s = "invalid SubModuleDecl"; break;
			case 156: s = "this symbol not expected in ClassDecl"; break;
			case 157: s = "this symbol not expected in ClassDecl"; break;
			case 158: s = "this symbol not expected in DatatypeDecl"; break;
			case 159: s = "invalid DatatypeDecl"; break;
			case 160: s = "invalid DatatypeDecl"; break;
			case 161: s = "invalid NewtypeDecl"; break;
			case 162: s = "invalid NewtypeDecl"; break;
			case 163: s = "invalid NewtypeDecl"; break;
			case 164: s = "invalid NewtypeDecl"; break;
			case 165: s = "invalid SynonymTypeDecl"; break;
			case 166: s = "invalid SynonymTypeDecl"; break;
			case 167: s = "invalid SynonymTypeDecl"; break;
			case 168: s = "this symbol not expected in IteratorDecl"; break;
			case 169: s = "invalid IteratorDecl"; break;
			case 170: s = "this symbol not expected in TraitDecl"; break;
			case 171: s = "invalid ClassMemberDecl"; break;
			case 172: s = "this symbol not expected in ModuleDefinition"; break;
			case 173: s = "invalid ModuleImport"; break;
			case 174: s = "invalid ModuleExport"; break;
			case 175: s = "invalid ModuleExport"; break;
			case 176: s = "invalid Ident"; break;
			case 177: s = "invalid NoUSIdentOrDigits"; break;
			case 178: s = "invalid ModuleExportSuffix"; break;
			case 179: s = "this symbol not expected in FieldDecl"; break;
			case 180: s = "this symbol not expected in ConstantFieldDecl"; break;
			case 181: s = "invalid ConstantFieldDecl"; break;
			case 182: s = "invalid FunctionDecl"; break;
			case 183: s = "invalid FunctionDecl"; break;
			case 184: s = "invalid FunctionDecl"; break;
			case 185: s = "invalid FunctionDecl"; break;
			case 186: s = "invalid FunctionDecl"; break;
			case 187: s = "invalid FunctionDecl"; break;
			case 188: s = "this symbol not expected in MethodDecl"; break;
			case 189: s = "invalid MethodDecl"; break;
			case 190: s = "invalid MethodDecl"; break;
			case 191: s = "invalid FIdentType"; break;
			case 192: s = "this symbol not expected in OldSemi"; break;
			case 193: s = "invalid GIdentType"; break;
			case 194: s = "invalid TypeIdentOptional"; break;
			case 195: s = "invalid TypeAndToken"; break;
			case 196: s = "this symbol not expected in IteratorSpec"; break;
			case 197: s = "invalid IteratorSpec"; break;
			case 198: s = "invalid Variance"; break;
			case 199: s = "invalid TPCharOption"; break;
			case 200: s = "invalid KType"; break;
			case 201: s = "this symbol not expected in MethodSpec"; break;
			case 202: s = "invalid FrameExpression"; break;
			case 203: s = "invalid PossiblyWildFrameExpression"; break;
			case 204: s = "invalid GenericInstantiation"; break;
			case 205: s = "invalid PredicateResult"; break;
			case 206: s = "this symbol not expected in FunctionSpec"; break;
			case 207: s = "invalid PossiblyWildExpression"; break;
			case 208: s = "invalid IdentOrDigits"; break;
			case 209: s = "this symbol not expected in OneStmt"; break;
			case 210: s = "invalid OneStmt"; break;
			case 211: s = "invalid UpdateStmt"; break;
			case 212: s = "invalid UpdateStmt"; break;
			case 213: s = "invalid UpdateStmt"; break;
			case 214: s = "invalid UpdateStmt"; break;
			case 215: s = "invalid UpdateStmt"; break;
			case 216: s = "invalid VarDeclStatement"; break;
			case 217: s = "this symbol not expected in VarDeclStatement"; break;
			case 218: s = "invalid VarDeclStatement"; break;
			case 219: s = "invalid VarDeclStatement"; break;
			case 220: s = "invalid IfStmt"; break;
			case 221: s = "invalid IfStmt"; break;
			case 222: s = "invalid WhileStmt"; break;
			case 223: s = "invalid WhileStmt"; break;
			case 224: s = "invalid ForLoopStmt"; break;
			case 225: s = "invalid ForLoopStmt"; break;
			case 226: s = "invalid AssertStmt"; break;
			case 227: s = "invalid AssertStmt"; break;
			case 228: s = "invalid AssumeStmt"; break;
			case 229: s = "invalid BreakStmt"; break;
			case 230: s = "invalid BreakStmt"; break;
			case 231: s = "this symbol not expected in BreakStmt"; break;
			case 232: s = "invalid CalcStmt"; break;
			case 233: s = "invalid ExpectStmt"; break;
			case 234: s = "invalid ForallStmt"; break;
			case 235: s = "invalid MatchStmt"; break;
			case 236: s = "invalid ModifyStmt"; break;
			case 237: s = "this symbol not expected in ModifyStmt"; break;
			case 238: s = "invalid ModifyStmt"; break;
			case 239: s = "invalid Rhs"; break;
			case 240: s = "invalid Rhs"; break;
			case 241: s = "invalid Lhs"; break;
			case 242: s = "invalid NewArray"; break;
			case 243: s = "invalid CasePatternLocal"; break;
			case 244: s = "invalid AlternativeBlock"; break;
			case 245: s = "invalid Guard"; break;
			case 246: s = "invalid AlternativeBlockCase"; break;
			case 247: s = "this symbol not expected in AlternativeBlockCase"; break;
			case 248: s = "this symbol not expected in AlternativeBlockCase"; break;
			case 249: s = "this symbol not expected in LoopSpec"; break;
			case 250: s = "this symbol not expected in LoopSpec"; break;
			case 251: s = "this symbol not expected in LoopSpec"; break;
			case 252: s = "invalid SingleExtendedPattern"; break;
			case 253: s = "invalid PossiblyNegatedLiteralExpr"; break;
			case 254: s = "invalid PossiblyNegatedLiteralExpr"; break;
			case 255: s = "this symbol not expected in CaseStmt"; break;
			case 256: s = "this symbol not expected in CaseStmt"; break;
			case 257: s = "invalid CalcOp"; break;
			case 258: s = "invalid ImpliesExpliesExpression"; break;
			case 259: s = "invalid ImpliesExpliesExpression"; break;
			case 260: s = "invalid LogicalExpression"; break;
			case 261: s = "invalid ImpliesExpression"; break;
			case 262: s = "invalid ShiftTerm"; break;
			case 263: s = "invalid RelOp"; break;
			case 264: s = "invalid AddOp"; break;
			case 265: s = "invalid BitvectorFactor"; break;
			case 266: s = "invalid BitvectorFactor"; break;
			case 267: s = "invalid MulOp"; break;
			case 268: s = "invalid AsExpression"; break;
			case 269: s = "invalid UnaryExpression"; break;
			case 270: s = "invalid PrimaryExpression"; break;
			case 271: s = "invalid MapDisplayExpr"; break;
			case 272: s = "invalid Suffix"; break;
			case 273: s = "invalid Suffix"; break;
			case 274: s = "invalid Suffix"; break;
			case 275: s = "invalid Suffix"; break;
			case 276: s = "invalid Suffix"; break;
			case 277: s = "invalid SetDisplayExpr"; break;
			case 278: s = "invalid LambdaExpression"; break;
			case 279: s = "invalid EndlessExpression"; break;
			case 280: s = "invalid NameSegment"; break;
			case 281: s = "invalid SeqDisplayExpr"; break;
			case 282: s = "invalid ConstAtomExpression"; break;
			case 283: s = "invalid LiteralExpression"; break;
			case 284: s = "invalid Nat"; break;
			case 285: s = "invalid MapComprehensionExpr"; break;
			case 286: s = "invalid IfExpression"; break;
			case 287: s = "invalid MatchExpression"; break;
			case 288: s = "invalid QuantifierExpression"; break;
			case 289: s = "invalid SetComprehensionExpr"; break;
			case 290: s = "invalid StmtInExpr"; break;
			case 291: s = "invalid LetExpression"; break;
			case 292: s = "invalid LetExprWithLHS"; break;
			case 293: s = "invalid CasePattern"; break;
			case 294: s = "invalid DotSuffix"; break;

      default: s = "error " + n; break;
    }
    return s;
  }

  public void SemErr(string errorId, IToken tok, string msg) {  // semantic errors
    Contract.Requires(tok != null);
    Contract.Requires(msg != null);
    ErrorCount++;
    Reporting.Error(MessageSource.Parser, errorId, tok, msg);
  }
  
  public void SemErr(Enum errorId, IToken tok, string msg) {  // semantic errors
    Contract.Requires(tok != null);
    Contract.Requires(msg != null);
    ErrorCount++;
    Reporting.Error(MessageSource.Parser, errorId, tok, msg);
  }

  public void SemErr(ErrorId errorId, Uri uri, int line, int col, string msg) {
    Contract.Requires(msg != null);
    ErrorCount++;
    Reporting.Error(MessageSource.Parser, errorId, uri, line, col, msg);
  }

  public void Deprecated(Enum errorId, IToken tok, string msg) {
    Contract.Requires(tok != null);
    Contract.Requires(msg != null);
    Reporting.Deprecated(MessageSource.Parser, errorId, tok, msg);
  }

  public void Warning(ErrorId errorId, IToken tok, string msg) {
    Contract.Requires(tok != null);
    Contract.Requires(msg != null);
    Reporting.Warning(MessageSource.Parser, errorId, tok, msg);
  }

} // Errors


public class FatalError: Exception {
  public FatalError(string m): base(m) {}
}
}